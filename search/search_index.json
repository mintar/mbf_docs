{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Move Base Flex: A Highly Flexible Navigation Framework: Move Base Flex (MBF) is a enhanced and flexible backwards-compatible replacement for move_base . In Short MBF, first are foremost, provides an enhanced version of the planner, controller and recovery plugin ROS interfaces . It exposes action servers for planning, controlling and recovering, providing detailed information of the current state and the plugin\u2019s feedback. An external executive logic can use MBF and its actions to perform smart and flexible navigation strategies. MBF enables the use of other map representations (besides cost maps), e.g. meshes or grid_map. Core Features Fully backwards-compatible with current ROS navigation. Actions for the submodules planning, controlling and recovering, and services to query the costmaps are provided. This interface allows external executives, e.g. SMACH, or Behavior Trees, to run highly flexible and complex navigation strategies. Comprehensive result and feedback information on all actions, including error codes and messages from the loaded plugins. For users still relying on a unique navigation interface, we have extended move_base action with detailed result and feedback information (though we still provide the current one). Separation between an abstract navigation framework and concrete implementations, allowing faster development of new applications, e.g. 3D navigation. Load multiple planners and controllers, selectable at runtime by setting one of the loaded plugin names in the action goal. Concurrency: Parallel planning, recovering, controlling by selecting different concurrency slots when defining the action goal. Only different plugins instances can run in parallel. Architecture Details Continue here Getting Started Follow the MBF Starting Guide and Tutorial See the Move Base Flex Documentation and Tutorials in the ROS wiki. Full code for the showcase and tutorials can be found in this repository .","title":"Home"},{"location":"#move-base-flex-a-highly-flexible-navigation-framework","text":"Move Base Flex (MBF) is a enhanced and flexible backwards-compatible replacement for move_base .","title":"Move Base Flex: A Highly Flexible Navigation Framework:"},{"location":"#in-short","text":"MBF, first are foremost, provides an enhanced version of the planner, controller and recovery plugin ROS interfaces . It exposes action servers for planning, controlling and recovering, providing detailed information of the current state and the plugin\u2019s feedback. An external executive logic can use MBF and its actions to perform smart and flexible navigation strategies. MBF enables the use of other map representations (besides cost maps), e.g. meshes or grid_map.","title":"In Short"},{"location":"#core-features","text":"Fully backwards-compatible with current ROS navigation. Actions for the submodules planning, controlling and recovering, and services to query the costmaps are provided. This interface allows external executives, e.g. SMACH, or Behavior Trees, to run highly flexible and complex navigation strategies. Comprehensive result and feedback information on all actions, including error codes and messages from the loaded plugins. For users still relying on a unique navigation interface, we have extended move_base action with detailed result and feedback information (though we still provide the current one). Separation between an abstract navigation framework and concrete implementations, allowing faster development of new applications, e.g. 3D navigation. Load multiple planners and controllers, selectable at runtime by setting one of the loaded plugin names in the action goal. Concurrency: Parallel planning, recovering, controlling by selecting different concurrency slots when defining the action goal. Only different plugins instances can run in parallel.","title":"Core Features"},{"location":"#architecture-details","text":"Continue here","title":"Architecture Details"},{"location":"#getting-started","text":"Follow the MBF Starting Guide and Tutorial See the Move Base Flex Documentation and Tutorials in the ROS wiki. Full code for the showcase and tutorials can be found in this repository .","title":"Getting Started"},{"location":"installation/","text":"Installation Supported platforms are ROS Kinetic, Melodic and Noetic ( Build Status ) The following packages must be installed to use Move Base Flex: ROS Kinetic+. Please follow the official installation guide for your distro . Don't forget setting up rosdep . Move Base Flex: For Use: apt install ros-$ROS_VERSION-move-base-flex For Development: clone the official move_base_flex repo into your catkin workspace At this point, you are ready for your first tutorial .","title":"Installation"},{"location":"installation/#installation","text":"Supported platforms are ROS Kinetic, Melodic and Noetic ( Build Status ) The following packages must be installed to use Move Base Flex: ROS Kinetic+. Please follow the official installation guide for your distro . Don't forget setting up rosdep . Move Base Flex: For Use: apt install ros-$ROS_VERSION-move-base-flex For Development: clone the official move_base_flex repo into your catkin workspace At this point, you are ready for your first tutorial .","title":"Installation"},{"location":"showcase/","text":"MBF showcase Navigation on 3D Meshes TODO Source: uos/mesh_navigation Default \"SimpleNavigationServer\" Navigation TODO","title":"Showcase"},{"location":"showcase/#mbf-showcase","text":"","title":"MBF showcase"},{"location":"showcase/#navigation-on-3d-meshes","text":"TODO Source: uos/mesh_navigation","title":"Navigation on 3D Meshes"},{"location":"showcase/#default-simplenavigationserver-navigation","text":"TODO","title":"Default \"SimpleNavigationServer\" Navigation"},{"location":"concepts/architecture/","text":"Concepts & Architecture We have created Move Base Flex for a larger target group besides the standard developers and users of move_base and 2D navigation based on costmaps, as well as addressed move_base's limitations. Since robot navigation can be separated into planning and controlling in many cases, even for outdoor scenarios without the benefits of flat terrain, we designed MBF based on abstract planner-, controller- and recovery behavior-execution classes for maximal flexibility . To accomplish this goal, we created abstract base classes for the nav core BaseLocalPlanner, BaseGlobalPlanner and RecoveryBehavior plugin interfaces, extending the API to provide a richer and more expressive interface without breaking the current move_base plugin API. The new abstract interfaces allow plugins to return valuable information in each execution cycle , e.g. why a valid plan or a velocity command could not be computed. This information is then passed to the external executive logic through MBF planning, navigation or recovering actions\u2019 feedback and result. The planner, controller and recovery behavior execution is implemented in the abstract execution classes without binding the software implementation to 2D costmaps (as in move_base). In our framework, move_base is just a particular implementation of a navigation system: its execution classes implement the abstract ones and bind the system to the costmaps. Thereby, the framework can easily be extended for customized navigation approaches , e.g. navigation on meshes or 3D occupancy grid maps. However, we provide a SimpleNavigationServer class without a binding to costmaps. Flowchart","title":"Architecture"},{"location":"concepts/architecture/#concepts-architecture","text":"We have created Move Base Flex for a larger target group besides the standard developers and users of move_base and 2D navigation based on costmaps, as well as addressed move_base's limitations. Since robot navigation can be separated into planning and controlling in many cases, even for outdoor scenarios without the benefits of flat terrain, we designed MBF based on abstract planner-, controller- and recovery behavior-execution classes for maximal flexibility . To accomplish this goal, we created abstract base classes for the nav core BaseLocalPlanner, BaseGlobalPlanner and RecoveryBehavior plugin interfaces, extending the API to provide a richer and more expressive interface without breaking the current move_base plugin API. The new abstract interfaces allow plugins to return valuable information in each execution cycle , e.g. why a valid plan or a velocity command could not be computed. This information is then passed to the external executive logic through MBF planning, navigation or recovering actions\u2019 feedback and result. The planner, controller and recovery behavior execution is implemented in the abstract execution classes without binding the software implementation to 2D costmaps (as in move_base). In our framework, move_base is just a particular implementation of a navigation system: its execution classes implement the abstract ones and bind the system to the costmaps. Thereby, the framework can easily be extended for customized navigation approaches , e.g. navigation on meshes or 3D occupancy grid maps. However, we provide a SimpleNavigationServer class without a binding to costmaps.","title":"Concepts &amp; Architecture"},{"location":"concepts/architecture/#flowchart","text":"","title":"Flowchart"},{"location":"concepts/navigation_servers/","text":"Navigation Servers Simple Navigation Server (built-int) Mesh Navigation etc etc","title":"Navigation Servers"},{"location":"concepts/navigation_servers/#navigation-servers","text":"Simple Navigation Server (built-int) Mesh Navigation etc etc","title":"Navigation Servers"},{"location":"tutorials/expert/","text":"Expert Tutorial TODO","title":"Expert"},{"location":"tutorials/expert/#expert-tutorial","text":"TODO","title":"Expert Tutorial"},{"location":"tutorials/mesh_navigation_stack/","text":"Mesh Navigation Stack TODO","title":"Mesh Navigation Stack"},{"location":"tutorials/mesh_navigation_stack/#mesh-navigation-stack","text":"TODO","title":"Mesh Navigation Stack"},{"location":"tutorials/overview/","text":"Welcome Welcome to the Move Base Flex Tutorials. Before you continue, make sure to have followed the Installation Instructions Tutorials Beginner Introduction to the ROS planning stack with Move Base (Flex) and a Turtlebot in Gazebo. Learn about Move Base and its configuration to send your robot to the requested location write a simple SMACH. Continue here Advanced The advanced tutorial will teach you the use of different Controllers and Planners at Runtime implementing intelligent Recovery Behavior Handling Continous Replanning Concurrency Slots for Simultaneous Replanning Continue here TODO Expert Multi Robot Navigation with one Move Base Flex Instance. Continue here TODO Writing Move Base Flex Plugins TODO Mesh Navigation Stack TODO","title":"Tutorials"},{"location":"tutorials/overview/#welcome","text":"Welcome to the Move Base Flex Tutorials. Before you continue, make sure to have followed the Installation Instructions","title":"Welcome"},{"location":"tutorials/overview/#tutorials","text":"Beginner Introduction to the ROS planning stack with Move Base (Flex) and a Turtlebot in Gazebo. Learn about Move Base and its configuration to send your robot to the requested location write a simple SMACH. Continue here Advanced The advanced tutorial will teach you the use of different Controllers and Planners at Runtime implementing intelligent Recovery Behavior Handling Continous Replanning Concurrency Slots for Simultaneous Replanning Continue here TODO Expert Multi Robot Navigation with one Move Base Flex Instance. Continue here TODO Writing Move Base Flex Plugins TODO Mesh Navigation Stack TODO","title":"Tutorials"},{"location":"tutorials/writing_mbf_plugins/","text":"Writing Move Base Flex Plugins TODO","title":"Writing MBF Plugins"},{"location":"tutorials/writing_mbf_plugins/#writing-move-base-flex-plugins","text":"TODO","title":"Writing Move Base Flex Plugins"},{"location":"tutorials/advanced/smach/","text":"Writing a SMACH This Tutorial will walk you through writing a simple SMACH. SMACH stands for S tate Mach ine and is an important concept in the ROS Navigation ecosystem. You can check out the official ROS SMACH Tutorials , as well. The tutorials up to this point focussed heavily on goal based actions. The following SMACH tutorial will show you how to use Move Base Flex to perform the planning yourself, giving you way more flexibility. Code TODO import rospy import smach import smach_ros from geometry_msgs.msg import PoseStamped from nav_msgs.msg import Path from mbf_msgs.msg import ExePathAction from mbf_msgs.msg import GetPathAction from mbf_msgs.msg import RecoveryAction def create_pose ( x , y , z , xx , yy , zz , ww ): pose = PoseStamped () pose . header . frame_id = \"map\" pose . header . stamp = rospy . Time . now () pose . pose . position . x = x pose . pose . position . y = y pose . pose . position . z = z pose . pose . orientation . x = xx pose . pose . orientation . y = yy pose . pose . orientation . z = zz pose . pose . orientation . w = ww return pose def iterate_target_poses (): target_poses = [ create_pose ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_pose ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), create_pose ( 0.957 , 1.60 , 0 , 0 , 0 , - 0.163 , 0.987 ), create_pose ( 1.8741 , 0.3830 , 0 , 0 , 0 , - 0.70 , 0.711 ), create_pose ( 1.752 , - 0.928 , 0 , 0 , 0 , - 0.856 , 0.517 ), create_pose ( 0.418 , - 2.116 , 0 , 0 , 0 , 0.998 , 0.0619 ), create_pose ( - 0.775 , - 1.80 , 0 , 0 , 0 , 0.954 , 0.300 ), create_pose ( - 1.990 , - 0.508 , 0 , 0 , 0 , - 0.112 , 0.999 ) ] for target_pose in target_poses : yield target_pose def create_path_goal ( path , tolerance_from_action , dist_tolerance , angle_tolerance ): goal = mbf_msgs . ExePathGoal () goal . path = path goal . tolerance_from_action = tolerance_from_action goal . dist_tolerance = dist_tolerance goal . angle_tolerance = angle_tolerance return goal def main (): rospy . init_node ( 'mbf_state_machine' ) target_poses = iterate_target_poses () # Create SMACH state machine sm = smach . StateMachine ( outcomes = [ 'succeeded' , 'aborted' , 'preempted' ]) # Define userdata sm . userdata . goal = None sm . userdata . path = None sm . userdata . error = None sm . userdata . clear_costmap_flag = False sm . userdata . error_status = None with sm : # path callback def get_path_callback ( userdata , goal ): goal . target_pose = next ( target_poses ) # Get path smach . StateMachine . add ( 'GET_PATH' , smach_ros . SimpleActionState ( '/move_base_flex/get_path' , GetPathAction , goal_cb = get_path_callback , goal_slots = [ 'target_pose' ], result_slots = [ 'path' ] ), transitions = { 'succeeded' : 'EXE_PATH' , 'aborted' : 'aborted' , 'preempted' : 'preempted' }, remapping = { 'target_pose' : 'goal' } ) def exe_path_callback ( userdata , goal ): target_pose = goal . path . poses [ - 1 ] . pose rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , target_pose . position . x , target_pose . position . y ) # Execute path smach . StateMachine . add ( 'EXE_PATH' , smach_ros . SimpleActionState ( '/move_base_flex/exe_path' , ExePathAction , goal_cb = exe_path_callback , goal_slots = [ 'path' ] ), transitions = { 'succeeded' : 'GET_PATH' , 'aborted' : 'aborted' , 'preempted' : 'preempted' } ) # Execute SMACH plan sm . execute () if __name__ == \"__main__\" : main () The Code Explained TODO","title":"Writing a simple SMACH"},{"location":"tutorials/advanced/smach/#writing-a-smach","text":"This Tutorial will walk you through writing a simple SMACH. SMACH stands for S tate Mach ine and is an important concept in the ROS Navigation ecosystem. You can check out the official ROS SMACH Tutorials , as well. The tutorials up to this point focussed heavily on goal based actions. The following SMACH tutorial will show you how to use Move Base Flex to perform the planning yourself, giving you way more flexibility.","title":"Writing a SMACH"},{"location":"tutorials/advanced/smach/#code","text":"TODO import rospy import smach import smach_ros from geometry_msgs.msg import PoseStamped from nav_msgs.msg import Path from mbf_msgs.msg import ExePathAction from mbf_msgs.msg import GetPathAction from mbf_msgs.msg import RecoveryAction def create_pose ( x , y , z , xx , yy , zz , ww ): pose = PoseStamped () pose . header . frame_id = \"map\" pose . header . stamp = rospy . Time . now () pose . pose . position . x = x pose . pose . position . y = y pose . pose . position . z = z pose . pose . orientation . x = xx pose . pose . orientation . y = yy pose . pose . orientation . z = zz pose . pose . orientation . w = ww return pose def iterate_target_poses (): target_poses = [ create_pose ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_pose ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), create_pose ( 0.957 , 1.60 , 0 , 0 , 0 , - 0.163 , 0.987 ), create_pose ( 1.8741 , 0.3830 , 0 , 0 , 0 , - 0.70 , 0.711 ), create_pose ( 1.752 , - 0.928 , 0 , 0 , 0 , - 0.856 , 0.517 ), create_pose ( 0.418 , - 2.116 , 0 , 0 , 0 , 0.998 , 0.0619 ), create_pose ( - 0.775 , - 1.80 , 0 , 0 , 0 , 0.954 , 0.300 ), create_pose ( - 1.990 , - 0.508 , 0 , 0 , 0 , - 0.112 , 0.999 ) ] for target_pose in target_poses : yield target_pose def create_path_goal ( path , tolerance_from_action , dist_tolerance , angle_tolerance ): goal = mbf_msgs . ExePathGoal () goal . path = path goal . tolerance_from_action = tolerance_from_action goal . dist_tolerance = dist_tolerance goal . angle_tolerance = angle_tolerance return goal def main (): rospy . init_node ( 'mbf_state_machine' ) target_poses = iterate_target_poses () # Create SMACH state machine sm = smach . StateMachine ( outcomes = [ 'succeeded' , 'aborted' , 'preempted' ]) # Define userdata sm . userdata . goal = None sm . userdata . path = None sm . userdata . error = None sm . userdata . clear_costmap_flag = False sm . userdata . error_status = None with sm : # path callback def get_path_callback ( userdata , goal ): goal . target_pose = next ( target_poses ) # Get path smach . StateMachine . add ( 'GET_PATH' , smach_ros . SimpleActionState ( '/move_base_flex/get_path' , GetPathAction , goal_cb = get_path_callback , goal_slots = [ 'target_pose' ], result_slots = [ 'path' ] ), transitions = { 'succeeded' : 'EXE_PATH' , 'aborted' : 'aborted' , 'preempted' : 'preempted' }, remapping = { 'target_pose' : 'goal' } ) def exe_path_callback ( userdata , goal ): target_pose = goal . path . poses [ - 1 ] . pose rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , target_pose . position . x , target_pose . position . y ) # Execute path smach . StateMachine . add ( 'EXE_PATH' , smach_ros . SimpleActionState ( '/move_base_flex/exe_path' , ExePathAction , goal_cb = exe_path_callback , goal_slots = [ 'path' ] ), transitions = { 'succeeded' : 'GET_PATH' , 'aborted' : 'aborted' , 'preempted' : 'preempted' } ) # Execute SMACH plan sm . execute () if __name__ == \"__main__\" : main ()","title":"Code"},{"location":"tutorials/advanced/smach/#the-code-explained","text":"TODO","title":"The Code Explained"},{"location":"tutorials/advanced/welcome/","text":"Advanced Tutorials Write your First State Machine (SMACH) TODO Continue here","title":"Welcome"},{"location":"tutorials/advanced/welcome/#advanced-tutorials","text":"Write your First State Machine (SMACH) TODO Continue here","title":"Advanced Tutorials"},{"location":"tutorials/beginner/basic_navigation/","text":"Basic Navigation Run tutorial For a quick demo, just follow the following steps. You will learn how to control the turtlebot in a simulation environment, with the help of RViz. Because this is so simple (in principle), we will relay Move Base Messages to Move Base Flex and let Move Base Flex take over planning. Let's begin. Clone mbf_tutorials git clone git@github.com:uos/mbf_tutorials.git ~/catkin_ws/src/mbf_tutorials Install dependencies with rosdep rosdep install turtlebot3_mbf Using ROS noetic? rosdep install will fail for eband_local_planner , because the team hasn't released the version for noetic yet. Simply clone the repository: git clone git@github.com:utexas-bwi/eband_local_planner.git ~/catkin_ws/src/eband_local_planner From source of workspace: cd ~/catkin_ws/src catkin_make -j4 && source devel/setup.bash ` Define the Turlebot model you want to use: export TURTLEBOT3_MODEL = burger Launch the appropriate gazebo world roslaunch turtlebot3_gazebo turtlebot3_world.launch Start localization (AMCL) roslaunch turtlebot3_mbf amcl_demo_relay_subscriber.launch Launch Rviz roslaunch turtlebot3_mbf rviz.launch In RViz Set an Initial Pose estimate with the 2D Pose Estimate Pose Finally set your Navigation Goal with the 2D Nav Goal Pose You will now be able to navigate in a similar fashion to this: What is happening here? We used Move Base Flex by relaying mb_msgs/MoveBaseAction to mbf_msgs/MoveBaseAction . Code import actionlib import rospy import nav_msgs.srv as nav_srvs import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs from geometry_msgs.msg import PoseStamped def simple_goal_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg )) rospy . logdebug ( \"Relaying move_base_simple/goal pose to mbf\" ) mbf_mb_ac . wait_for_result () status = mbf_mb_ac . get_state () result = mbf_mb_ac . get_result () rospy . logdebug ( \"MBF execution completed with result [ %d ]: %s \" , result . outcome , result . message ) if __name__ == '__main__' : rospy . init_node ( \"move_base_relay\" ) # move base flex ation client relays incoming mb goals to mbf mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 20 )) # move_base simple topic and action server mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) rospy . spin () The Code Explained MoveBase subscriber to handle goal events mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) MoveBase expects goal Messages ( geometry_msgs/Pose ) on topic move_base_simple/goal . The subscriber callback simple_goal_cb handles the mbf_msgs.MoveBaseAction ROS Action Client. The Move Base Flex SimpleActionServer is launched from within Move Base Flex. mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) ... def simple_goal_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg )) and relays the MoveBaseAction to the Move Base Flex action client! At this stage, we are using the global planner and local planner defined in move_base.yml . A Relay with more control While the first example allows you to relay messages to Move Base Flex, the only way to reach goals is by setting a 2D Navigation Goal via RViz, which can be limiting. This examples allows you to send goals directly from a ROS node. Code Server import actionlib import rospy import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs def mb_execute_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg . target_pose ), feedback_cb = mbf_feedback_cb ) rospy . logdebug ( \"Relaying move_base goal to mbf\" ) mbf_mb_ac . wait_for_result () status = mbf_mb_ac . get_state () result = mbf_mb_ac . get_result () rospy . logdebug ( \"MBF execution completed with result [ %d ]: %s \" , result . outcome , result . message ) if result . outcome == mbf_msgs . MoveBaseResult . SUCCESS : mb_as . set_succeeded ( mb_msgs . MoveBaseResult (), \"Goal reached.\" ) else : mb_as . set_aborted ( mb_msgs . MoveBaseResult (), result . message ) def mbf_feedback_cb ( feedback ): mb_as . publish_feedback ( mb_msgs . MoveBaseFeedback ( base_position = feedback . current_pose )) if __name__ == '__main__' : rospy . init_node ( \"move_base\" ) # move_base_flex get_path and move_base action clients mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 10 )) mb_as = actionlib . SimpleActionServer ( 'move_base' , mb_msgs . MoveBaseAction , mb_execute_cb , auto_start = False ) mb_as . start () rospy . spin () Client import rospy import actionlib import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs from actionlib_msgs.msg import GoalStatus def create_goal ( x , y , z , xx , yy , zz , ww ): goal = mb_msgs . MoveBaseGoal () ... goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z ... return goal def move ( goal ): client . send_goal ( goal ) client . wait_for_result () return client . get_state () == GoalStatus . SUCCEEDED def drive_circle (): goals = [ create_goal ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_goal ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), ... ] for goal in goals : rospy . loginfo ( \"Attempting to drive to %s %s \" , goal . target_pose . pose . position . x , goal . target_pose . pose . position . y ) if not move ( goal ): return False return True if __name__ == '__main__' : try : rospy . init_node ( 'mb_relay_client' ) client = actionlib . SimpleActionClient ( 'move_base' , mb_msgs . MoveBaseAction ) client . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to SimpleActionServer 'move_base'\" ) result = drive_circle () rospy . loginfo ( \"Drove circle with result: %s \" , result ) except rospy . ROSInterruptException : rospy . logerror ( \"program interrupted before completion\" ) The Code Explained On the server side, we start a standard Move Base Action Server, and connect a Move Base Flex Action Client to the default Move Base Flex Action Server. mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 10 )) mb_as = actionlib . SimpleActionServer ( 'move_base' , mb_msgs . MoveBaseAction , mb_execute_cb , auto_start = False ) We then relay the goal in the callback of the Move Base Action Server, like in the first subriber callback example def mb_execute_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg . target_pose ), feedback_cb = mbf_feedback_cb ) On the client side, we simply connect to the Move Base Action Server, and send a goal, which is then relayed in the above function. client = actionlib . SimpleActionClient ( 'move_base' , mb_msgs . MoveBaseAction ) client . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to SimpleActionServer 'move_base'\" ) In this example, the robot will follow a (rough) circular path around the turtlebot3_gazebo world. A goal is created like this: goal = mb_msgs . MoveBaseGoal () goal . target_pose . header . frame_id = \"map\" goal . target_pose . header . stamp = rospy . Time . now () goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z goal . target_pose . pose . orientation . x = xx goal . target_pose . pose . orientation . y = yy goal . target_pose . pose . orientation . z = zz goal . target_pose . pose . orientation . w = ww return goal and sent to the action server: client . send_goal ( goal ) client . wait_for_result () return client . get_state () == GoalStatus . SUCCEEDED Run the example Launch gazebo export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch as well as the server export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_mbf amcl_demo_relay_server.launch and client node to send the goals! rosrun turtlebot3_mbf mb_relay_client.py The Result Open RViz with roslaunch turtlebot3_mbf rviz.launch The full source code can be found here .","title":"Basic Navigation"},{"location":"tutorials/beginner/basic_navigation/#basic-navigation","text":"","title":"Basic Navigation"},{"location":"tutorials/beginner/basic_navigation/#run-tutorial","text":"For a quick demo, just follow the following steps. You will learn how to control the turtlebot in a simulation environment, with the help of RViz. Because this is so simple (in principle), we will relay Move Base Messages to Move Base Flex and let Move Base Flex take over planning. Let's begin. Clone mbf_tutorials git clone git@github.com:uos/mbf_tutorials.git ~/catkin_ws/src/mbf_tutorials Install dependencies with rosdep rosdep install turtlebot3_mbf Using ROS noetic? rosdep install will fail for eband_local_planner , because the team hasn't released the version for noetic yet. Simply clone the repository: git clone git@github.com:utexas-bwi/eband_local_planner.git ~/catkin_ws/src/eband_local_planner From source of workspace: cd ~/catkin_ws/src catkin_make -j4 && source devel/setup.bash ` Define the Turlebot model you want to use: export TURTLEBOT3_MODEL = burger Launch the appropriate gazebo world roslaunch turtlebot3_gazebo turtlebot3_world.launch Start localization (AMCL) roslaunch turtlebot3_mbf amcl_demo_relay_subscriber.launch Launch Rviz roslaunch turtlebot3_mbf rviz.launch In RViz Set an Initial Pose estimate with the 2D Pose Estimate Pose Finally set your Navigation Goal with the 2D Nav Goal Pose You will now be able to navigate in a similar fashion to this:","title":"Run tutorial"},{"location":"tutorials/beginner/basic_navigation/#what-is-happening-here","text":"We used Move Base Flex by relaying mb_msgs/MoveBaseAction to mbf_msgs/MoveBaseAction .","title":"What is happening here?"},{"location":"tutorials/beginner/basic_navigation/#code","text":"import actionlib import rospy import nav_msgs.srv as nav_srvs import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs from geometry_msgs.msg import PoseStamped def simple_goal_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg )) rospy . logdebug ( \"Relaying move_base_simple/goal pose to mbf\" ) mbf_mb_ac . wait_for_result () status = mbf_mb_ac . get_state () result = mbf_mb_ac . get_result () rospy . logdebug ( \"MBF execution completed with result [ %d ]: %s \" , result . outcome , result . message ) if __name__ == '__main__' : rospy . init_node ( \"move_base_relay\" ) # move base flex ation client relays incoming mb goals to mbf mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 20 )) # move_base simple topic and action server mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) rospy . spin ()","title":"Code"},{"location":"tutorials/beginner/basic_navigation/#the-code-explained","text":"MoveBase subscriber to handle goal events mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) MoveBase expects goal Messages ( geometry_msgs/Pose ) on topic move_base_simple/goal . The subscriber callback simple_goal_cb handles the mbf_msgs.MoveBaseAction ROS Action Client. The Move Base Flex SimpleActionServer is launched from within Move Base Flex. mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) ... def simple_goal_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg )) and relays the MoveBaseAction to the Move Base Flex action client! At this stage, we are using the global planner and local planner defined in move_base.yml .","title":"The Code Explained"},{"location":"tutorials/beginner/basic_navigation/#a-relay-with-more-control","text":"While the first example allows you to relay messages to Move Base Flex, the only way to reach goals is by setting a 2D Navigation Goal via RViz, which can be limiting. This examples allows you to send goals directly from a ROS node.","title":"A Relay with more control"},{"location":"tutorials/beginner/basic_navigation/#code_1","text":"Server import actionlib import rospy import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs def mb_execute_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg . target_pose ), feedback_cb = mbf_feedback_cb ) rospy . logdebug ( \"Relaying move_base goal to mbf\" ) mbf_mb_ac . wait_for_result () status = mbf_mb_ac . get_state () result = mbf_mb_ac . get_result () rospy . logdebug ( \"MBF execution completed with result [ %d ]: %s \" , result . outcome , result . message ) if result . outcome == mbf_msgs . MoveBaseResult . SUCCESS : mb_as . set_succeeded ( mb_msgs . MoveBaseResult (), \"Goal reached.\" ) else : mb_as . set_aborted ( mb_msgs . MoveBaseResult (), result . message ) def mbf_feedback_cb ( feedback ): mb_as . publish_feedback ( mb_msgs . MoveBaseFeedback ( base_position = feedback . current_pose )) if __name__ == '__main__' : rospy . init_node ( \"move_base\" ) # move_base_flex get_path and move_base action clients mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 10 )) mb_as = actionlib . SimpleActionServer ( 'move_base' , mb_msgs . MoveBaseAction , mb_execute_cb , auto_start = False ) mb_as . start () rospy . spin () Client import rospy import actionlib import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs from actionlib_msgs.msg import GoalStatus def create_goal ( x , y , z , xx , yy , zz , ww ): goal = mb_msgs . MoveBaseGoal () ... goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z ... return goal def move ( goal ): client . send_goal ( goal ) client . wait_for_result () return client . get_state () == GoalStatus . SUCCEEDED def drive_circle (): goals = [ create_goal ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_goal ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), ... ] for goal in goals : rospy . loginfo ( \"Attempting to drive to %s %s \" , goal . target_pose . pose . position . x , goal . target_pose . pose . position . y ) if not move ( goal ): return False return True if __name__ == '__main__' : try : rospy . init_node ( 'mb_relay_client' ) client = actionlib . SimpleActionClient ( 'move_base' , mb_msgs . MoveBaseAction ) client . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to SimpleActionServer 'move_base'\" ) result = drive_circle () rospy . loginfo ( \"Drove circle with result: %s \" , result ) except rospy . ROSInterruptException : rospy . logerror ( \"program interrupted before completion\" )","title":"Code"},{"location":"tutorials/beginner/basic_navigation/#the-code-explained_1","text":"On the server side, we start a standard Move Base Action Server, and connect a Move Base Flex Action Client to the default Move Base Flex Action Server. mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 10 )) mb_as = actionlib . SimpleActionServer ( 'move_base' , mb_msgs . MoveBaseAction , mb_execute_cb , auto_start = False ) We then relay the goal in the callback of the Move Base Action Server, like in the first subriber callback example def mb_execute_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg . target_pose ), feedback_cb = mbf_feedback_cb ) On the client side, we simply connect to the Move Base Action Server, and send a goal, which is then relayed in the above function. client = actionlib . SimpleActionClient ( 'move_base' , mb_msgs . MoveBaseAction ) client . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to SimpleActionServer 'move_base'\" ) In this example, the robot will follow a (rough) circular path around the turtlebot3_gazebo world. A goal is created like this: goal = mb_msgs . MoveBaseGoal () goal . target_pose . header . frame_id = \"map\" goal . target_pose . header . stamp = rospy . Time . now () goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z goal . target_pose . pose . orientation . x = xx goal . target_pose . pose . orientation . y = yy goal . target_pose . pose . orientation . z = zz goal . target_pose . pose . orientation . w = ww return goal and sent to the action server: client . send_goal ( goal ) client . wait_for_result () return client . get_state () == GoalStatus . SUCCEEDED","title":"The Code Explained"},{"location":"tutorials/beginner/basic_navigation/#run-the-example","text":"Launch gazebo export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch as well as the server export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_mbf amcl_demo_relay_server.launch and client node to send the goals! rosrun turtlebot3_mbf mb_relay_client.py","title":"Run the example"},{"location":"tutorials/beginner/basic_navigation/#the-result","text":"Open RViz with roslaunch turtlebot3_mbf rviz.launch The full source code can be found here .","title":"The Result"},{"location":"tutorials/beginner/beyond_relay/","text":"Leaving the Relay Behind Using a relay from Move Base to Move Base Flex is the easiest way to get started with Move Base Flex, when coming from Move Base. This does, however, make it harder to use advanced features of Move Base Flex. Let's start with understanding the differences between the respective Actions: mb_msgs/MoveBaseAction vs mbf_msgs/MoveBaseAction mb_msgs/MoveBaseAction In principle, every Move Base Action is defined as geometry_msgs/PoseStamped target_pose --- No Result Feedback (default) --- geometry_msgs/PoseStamped base_position Source mbf_msgs/MoveBaseAction Move Base Flex uses the same target/result feedback/action feedback structure, but adds new functionality: More detailed result feedback (per default) More defailed feedback possibilities plugins: controller (local planner), planner (global planner), recovery_behaviors geometry_msgs/PoseStamped target_pose # Controller to use; defaults to the first one specified on \"controllers\" parameter string controller # Planner to use; defaults to the first one specified on \"planners\" parameter string planner # Recovery behaviors to try on case of failure; defaults to the \"recovery_behaviors\" parameter value string[] recovery_behaviors --- # Predefined success codes: uint8 SUCCESS = 0 # Predefined general error codes: uint8 FAILURE = 10 uint8 CANCELED = 11 uint8 COLLISION = 12 uint8 OSCILLATION = 13 uint8 START_BLOCKED = 14 uint8 GOAL_BLOCKED = 15 uint8 TF_ERROR = 16 uint8 INTERNAL_ERROR = 17 # 21..49 are reserved for future general error codes # Planning/controlling failures: uint8 PLAN_FAILURE = 50 # 51..99 are reserved as planner specific errors uint8 CTRL_FAILURE = 100 # 101..149 are reserved as controller specific errors uint32 outcome string message # Configuration upon action completion float32 dist_to_goal float32 angle_to_goal geometry_msgs/PoseStamped final_pose --- # Outcome of most recent controller cycle. Same values as in MoveBase or ExePath result. uint32 outcome string message float32 dist_to_goal float32 angle_to_goal geometry_msgs/PoseStamped current_pose geometry_msgs/TwistStamped last_cmd_vel # last command calculated by the controller` Source Interacting with Move Base Flex From a client perspective, the primary interface to work with Move Base Flex is the actionlibs SimpleActionServer. If you have never heard of actionlib, the ROS Wiki has some good tutorials for it. We did, however, already use actionlib in earlier parts of this tutorial. In principle, a SimpleActionServer expects a name and an action (ROS message type) that it will perform. A SimpleActionClient can then connect to the Server by name and Action and send respective goals , which are just the specific action with a ROS header and Goal ID. Driving a Circle with Move Base Flex In the previous example, we used a relay to Move Base with a Move Base SimpleActionServer . Using this method, the Move Base Flex is hidden, so to speak, inside the relay, and the corresponding Move Base Client is limited to the functionality of the Move Base Action Server. The following example will use the additional information the Move Base Flex Action Server provides. We can use the Move Base Flex Action server that is started with Move Base Flex to interact with the framework directly. This is the circle driving robot with Move Base Flex only. Code import actionlib import rospy import mbf_msgs.msg as mbf_msgs def create_goal ( x , y , z , xx , yy , zz , ww ): goal = mbf_msgs . MoveBaseGoal () goal . target_pose . header . frame_id = \"map\" goal . target_pose . header . stamp = rospy . Time . now () goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z goal . target_pose . pose . orientation . x = xx goal . target_pose . pose . orientation . y = yy goal . target_pose . pose . orientation . z = zz goal . target_pose . pose . orientation . w = ww return goal def move ( goal ): mbf_ac . send_goal ( goal ) mbf_ac . wait_for_result () return mbf_ac . get_result () def drive_circle (): goals = [ create_goal ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_goal ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), create_goal ( 0.957 , 1.60 , 0 , 0 , 0 , - 0.163 , 0.987 ), create_goal ( 1.8741 , 0.3830 , 0 , 0 , 0 , - 0.70 , 0.711 ), create_goal ( 1.752 , - 0.928 , 0 , 0 , 0 , - 0.856 , 0.517 ), create_goal ( 0.418 , - 2.116 , 0 , 0 , 0 , 0.998 , 0.0619 ), create_goal ( - 0.775 , - 1.80 , 0 , 0 , 0 , 0.954 , 0.300 ), create_goal ( - 1.990 , - 0.508 , 0 , 0 , 0 , - 0.112 , 0.999 ) ] for goal in goals : rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , goal . target_pose . pose . position . x , goal . target_pose . pose . position . y ) result = move ( goal ) if result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete action: %s \" , result . message ) return if __name__ == '__main__' : rospy . init_node ( \"move_base_flex_client\" ) mbf_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex action server!\" ) drive_circle () The Code Explained We start by creating the Move Base Flex Action Client that tries to connect to the server running at /move_base_flex/move_base . mbf_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex action server!\" ) To actually drive the circle, we can create goals of type mbf_msgs.MoveBaseGoal def create_goal ( x , y , z , xx , yy , zz , ww ): goal = mbf_msgs . MoveBaseGoal () goal . target_pose . header . frame_id = \"map\" goal . target_pose . header . stamp = rospy . Time . now () goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z goal . target_pose . pose . orientation . x = xx goal . target_pose . pose . orientation . y = yy goal . target_pose . pose . orientation . z = zz goal . target_pose . pose . orientation . w = ww return goal and send them to the Server def move ( goal ): mbf_ac . send_goal ( goal ) mbf_ac . wait_for_result () return mbf_ac . get_result () and can check for additional, rich result information like outcome, message and others (see first Section overview of mbf_msgs/MoveBaseAction ) if result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete action: %s \" , result . message ) return Run the example Launch gazebo export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch as well as the Move Base Flex Action Server export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_mbf amcl_demo_mbf.launch and client node to send the goals! rosrun turtlebot3_mbf mbf_goal_client.py The Result Open RViz with roslaunch turtlebot3_mbf rviz.launch The full source code can be found here .","title":"Beyond the Relay - Move Base Flex"},{"location":"tutorials/beginner/beyond_relay/#leaving-the-relay-behind","text":"Using a relay from Move Base to Move Base Flex is the easiest way to get started with Move Base Flex, when coming from Move Base. This does, however, make it harder to use advanced features of Move Base Flex. Let's start with understanding the differences between the respective Actions:","title":"Leaving the Relay Behind"},{"location":"tutorials/beginner/beyond_relay/#mb_msgsmovebaseaction-vs-mbf_msgsmovebaseaction","text":"mb_msgs/MoveBaseAction In principle, every Move Base Action is defined as geometry_msgs/PoseStamped target_pose --- No Result Feedback (default) --- geometry_msgs/PoseStamped base_position Source mbf_msgs/MoveBaseAction Move Base Flex uses the same target/result feedback/action feedback structure, but adds new functionality: More detailed result feedback (per default) More defailed feedback possibilities plugins: controller (local planner), planner (global planner), recovery_behaviors geometry_msgs/PoseStamped target_pose # Controller to use; defaults to the first one specified on \"controllers\" parameter string controller # Planner to use; defaults to the first one specified on \"planners\" parameter string planner # Recovery behaviors to try on case of failure; defaults to the \"recovery_behaviors\" parameter value string[] recovery_behaviors --- # Predefined success codes: uint8 SUCCESS = 0 # Predefined general error codes: uint8 FAILURE = 10 uint8 CANCELED = 11 uint8 COLLISION = 12 uint8 OSCILLATION = 13 uint8 START_BLOCKED = 14 uint8 GOAL_BLOCKED = 15 uint8 TF_ERROR = 16 uint8 INTERNAL_ERROR = 17 # 21..49 are reserved for future general error codes # Planning/controlling failures: uint8 PLAN_FAILURE = 50 # 51..99 are reserved as planner specific errors uint8 CTRL_FAILURE = 100 # 101..149 are reserved as controller specific errors uint32 outcome string message # Configuration upon action completion float32 dist_to_goal float32 angle_to_goal geometry_msgs/PoseStamped final_pose --- # Outcome of most recent controller cycle. Same values as in MoveBase or ExePath result. uint32 outcome string message float32 dist_to_goal float32 angle_to_goal geometry_msgs/PoseStamped current_pose geometry_msgs/TwistStamped last_cmd_vel # last command calculated by the controller` Source","title":"mb_msgs/MoveBaseAction vs mbf_msgs/MoveBaseAction"},{"location":"tutorials/beginner/beyond_relay/#interacting-with-move-base-flex","text":"From a client perspective, the primary interface to work with Move Base Flex is the actionlibs SimpleActionServer. If you have never heard of actionlib, the ROS Wiki has some good tutorials for it. We did, however, already use actionlib in earlier parts of this tutorial. In principle, a SimpleActionServer expects a name and an action (ROS message type) that it will perform. A SimpleActionClient can then connect to the Server by name and Action and send respective goals , which are just the specific action with a ROS header and Goal ID.","title":"Interacting with Move Base Flex"},{"location":"tutorials/beginner/beyond_relay/#driving-a-circle-with-move-base-flex","text":"In the previous example, we used a relay to Move Base with a Move Base SimpleActionServer . Using this method, the Move Base Flex is hidden, so to speak, inside the relay, and the corresponding Move Base Client is limited to the functionality of the Move Base Action Server. The following example will use the additional information the Move Base Flex Action Server provides. We can use the Move Base Flex Action server that is started with Move Base Flex to interact with the framework directly. This is the circle driving robot with Move Base Flex only.","title":"Driving a Circle with Move Base Flex"},{"location":"tutorials/beginner/beyond_relay/#code","text":"import actionlib import rospy import mbf_msgs.msg as mbf_msgs def create_goal ( x , y , z , xx , yy , zz , ww ): goal = mbf_msgs . MoveBaseGoal () goal . target_pose . header . frame_id = \"map\" goal . target_pose . header . stamp = rospy . Time . now () goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z goal . target_pose . pose . orientation . x = xx goal . target_pose . pose . orientation . y = yy goal . target_pose . pose . orientation . z = zz goal . target_pose . pose . orientation . w = ww return goal def move ( goal ): mbf_ac . send_goal ( goal ) mbf_ac . wait_for_result () return mbf_ac . get_result () def drive_circle (): goals = [ create_goal ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_goal ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), create_goal ( 0.957 , 1.60 , 0 , 0 , 0 , - 0.163 , 0.987 ), create_goal ( 1.8741 , 0.3830 , 0 , 0 , 0 , - 0.70 , 0.711 ), create_goal ( 1.752 , - 0.928 , 0 , 0 , 0 , - 0.856 , 0.517 ), create_goal ( 0.418 , - 2.116 , 0 , 0 , 0 , 0.998 , 0.0619 ), create_goal ( - 0.775 , - 1.80 , 0 , 0 , 0 , 0.954 , 0.300 ), create_goal ( - 1.990 , - 0.508 , 0 , 0 , 0 , - 0.112 , 0.999 ) ] for goal in goals : rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , goal . target_pose . pose . position . x , goal . target_pose . pose . position . y ) result = move ( goal ) if result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete action: %s \" , result . message ) return if __name__ == '__main__' : rospy . init_node ( \"move_base_flex_client\" ) mbf_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex action server!\" ) drive_circle ()","title":"Code"},{"location":"tutorials/beginner/beyond_relay/#the-code-explained","text":"We start by creating the Move Base Flex Action Client that tries to connect to the server running at /move_base_flex/move_base . mbf_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex action server!\" ) To actually drive the circle, we can create goals of type mbf_msgs.MoveBaseGoal def create_goal ( x , y , z , xx , yy , zz , ww ): goal = mbf_msgs . MoveBaseGoal () goal . target_pose . header . frame_id = \"map\" goal . target_pose . header . stamp = rospy . Time . now () goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z goal . target_pose . pose . orientation . x = xx goal . target_pose . pose . orientation . y = yy goal . target_pose . pose . orientation . z = zz goal . target_pose . pose . orientation . w = ww return goal and send them to the Server def move ( goal ): mbf_ac . send_goal ( goal ) mbf_ac . wait_for_result () return mbf_ac . get_result () and can check for additional, rich result information like outcome, message and others (see first Section overview of mbf_msgs/MoveBaseAction ) if result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete action: %s \" , result . message ) return","title":"The Code Explained"},{"location":"tutorials/beginner/beyond_relay/#run-the-example","text":"Launch gazebo export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch as well as the Move Base Flex Action Server export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_mbf amcl_demo_mbf.launch and client node to send the goals! rosrun turtlebot3_mbf mbf_goal_client.py","title":"Run the example"},{"location":"tutorials/beginner/beyond_relay/#the-result","text":"Open RViz with roslaunch turtlebot3_mbf rviz.launch The full source code can be found here .","title":"The Result"},{"location":"tutorials/beginner/parameters/","text":"Parameters and Configuration Dynamically Reconfigurable Parameters The following parameters are changable at runtime, with rqt_reconfigure , or with launch file arguments Planners Name Explanation Default planners global planner, e.g. navfn/NavfnROS planner_frequency The rate in Hz at which to run the planning loop 0.0 ?? planner_max_retries How many times we will recall the planner in an attempt to find a valid plan before giving up -1. ?? planner_patience How long the planner will wait in seconds in an attempt to find a valid plan before giving up 5.0 Controllers Name Explanation Default controllers list of controller, e.g. eband_local_planner/EBandPlannerROS controller_frequency The rate in Hz at which to run the control loop and send velocity commands to the base 20.0 controller_max_retries How many times we will recall the controller in an attempt to find a valid command before giving up -1 controller_patience How long the controller will wait in seconds without receiving a valid control before giving up 5.0 Oscillation Name Explanation Default oscillation_distance How far in meters the robot must move to be considered not to be oscillating 0.5 oscillation_timeout How long in seconds to allow for oscillation before executing recovery behaviors 0.0 Other Name Explanation Default recovery_enabled enable the move_base_flex recovery behaviors to attempt to clear out space true recovery_patience How much time we allow recovery behaviors to complete before canceling (or stopping if cancel fails) 15.0 restore_defaults Restore to the original configuration false shutdown_costmaps shutdown the costmaps of the node when move_base_flex is in an inactive state false shutdown_costmaps_delay How long in seconds to wait after last action before shutting down the costmaps 1.0 Sources mbf_abstract_nav mbf_costmap_nav To use rqt_reconfigure , run rosrun rqt_reconfigure rqt_reconfigure Static Parameters Move Base Flex has a number of parameters, that are not dynamically changable Name Explanation Default robot_frame the frame of the robot, which will be used to determine its position \"base_link\" map_frame the global frame the robot is controlling in \"map\" force_stop_at_goal force move base flex to stop the robot once the goal is reached false force_stop_on_cancel force move base flex to stop the robot on navigation cancellation false mbf_tolerance_check force move base flex to check for the goal tolerance false dist_tolerance distance tolerance to the given goal pose 0.1 angle_tolerance angle tolerance to the given goal pose \u03c0 / 18.0 tf_timeout time before a timeout used for tf requests 1.0","title":"Parameters and Configuration"},{"location":"tutorials/beginner/parameters/#parameters-and-configuration","text":"","title":"Parameters and Configuration"},{"location":"tutorials/beginner/parameters/#dynamically-reconfigurable-parameters","text":"The following parameters are changable at runtime, with rqt_reconfigure , or with launch file arguments","title":"Dynamically Reconfigurable Parameters"},{"location":"tutorials/beginner/parameters/#planners","text":"Name Explanation Default planners global planner, e.g. navfn/NavfnROS planner_frequency The rate in Hz at which to run the planning loop 0.0 ?? planner_max_retries How many times we will recall the planner in an attempt to find a valid plan before giving up -1. ?? planner_patience How long the planner will wait in seconds in an attempt to find a valid plan before giving up 5.0","title":"Planners"},{"location":"tutorials/beginner/parameters/#controllers","text":"Name Explanation Default controllers list of controller, e.g. eband_local_planner/EBandPlannerROS controller_frequency The rate in Hz at which to run the control loop and send velocity commands to the base 20.0 controller_max_retries How many times we will recall the controller in an attempt to find a valid command before giving up -1 controller_patience How long the controller will wait in seconds without receiving a valid control before giving up 5.0","title":"Controllers"},{"location":"tutorials/beginner/parameters/#oscillation","text":"Name Explanation Default oscillation_distance How far in meters the robot must move to be considered not to be oscillating 0.5 oscillation_timeout How long in seconds to allow for oscillation before executing recovery behaviors 0.0","title":"Oscillation"},{"location":"tutorials/beginner/parameters/#other","text":"Name Explanation Default recovery_enabled enable the move_base_flex recovery behaviors to attempt to clear out space true recovery_patience How much time we allow recovery behaviors to complete before canceling (or stopping if cancel fails) 15.0 restore_defaults Restore to the original configuration false shutdown_costmaps shutdown the costmaps of the node when move_base_flex is in an inactive state false shutdown_costmaps_delay How long in seconds to wait after last action before shutting down the costmaps 1.0","title":"Other"},{"location":"tutorials/beginner/parameters/#sources","text":"mbf_abstract_nav mbf_costmap_nav To use rqt_reconfigure , run rosrun rqt_reconfigure rqt_reconfigure","title":"Sources"},{"location":"tutorials/beginner/parameters/#static-parameters","text":"Move Base Flex has a number of parameters, that are not dynamically changable Name Explanation Default robot_frame the frame of the robot, which will be used to determine its position \"base_link\" map_frame the global frame the robot is controlling in \"map\" force_stop_at_goal force move base flex to stop the robot once the goal is reached false force_stop_on_cancel force move base flex to stop the robot on navigation cancellation false mbf_tolerance_check force move base flex to check for the goal tolerance false dist_tolerance distance tolerance to the given goal pose 0.1 angle_tolerance angle tolerance to the given goal pose \u03c0 / 18.0 tf_timeout time before a timeout used for tf requests 1.0","title":"Static Parameters"},{"location":"tutorials/beginner/path_planning/","text":"Path Planning These tutorials have focused on sending goals to Move Base Flex via its Simple Action Client listening to /move_base_flex/move_base . In many instances, it is helpful to have access to the full planned path, which this tutorial will cover! Code The turtlebot will drive the same circle as in previous tutorials, but will use the /move_base_flex/exe_path Action Server to execute path goals, and the /move_base_flex/get_path Action Server to plan paths to target poses. import actionlib import rospy import mbf_msgs.msg as mbf_msgs import geometry_msgs.msg as geometry_msgs def create_pose ( x , y , z , xx , yy , zz , ww ): pose = geometry_msgs . PoseStamped () pose . header . frame_id = \"map\" pose . header . stamp = rospy . Time . now () pose . pose . position . x = x pose . pose . position . y = y pose . pose . position . z = z pose . pose . orientation . x = xx pose . pose . orientation . y = yy pose . pose . orientation . z = zz pose . pose . orientation . w = ww return pose def create_path_goal ( path , tolerance_from_action , dist_tolerance , angle_tolerance ): goal = mbf_msgs . ExePathGoal () goal . path = path goal . tolerance_from_action = tolerance_from_action goal . dist_tolerance = dist_tolerance goal . angle_tolerance = angle_tolerance return goal def exe_path ( path_goal ): mbf_ep_ac . send_goal ( path_goal ) mbf_ep_ac . wait_for_result () return mbf_ep_ac . get_result () def get_plan ( pose ): path_goal = mbf_msgs . GetPathGoal ( target_pose = pose , tolerance = 0.5 ) mbf_gp_ac . send_goal ( path_goal ) mbf_gp_ac . wait_for_result () return mbf_gp_ac . get_result () def drive_circle (): target_poses = [ create_pose ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_pose ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), create_pose ( 0.957 , 1.60 , 0 , 0 , 0 , - 0.163 , 0.987 ), create_pose ( 1.8741 , 0.3830 , 0 , 0 , 0 , - 0.70 , 0.711 ), create_pose ( 1.752 , - 0.928 , 0 , 0 , 0 , - 0.856 , 0.517 ), create_pose ( 0.418 , - 2.116 , 0 , 0 , 0 , 0.998 , 0.0619 ), create_pose ( - 0.775 , - 1.80 , 0 , 0 , 0 , 0.954 , 0.300 ), create_pose ( - 1.990 , - 0.508 , 0 , 0 , 0 , - 0.112 , 0.999 ) ] for target_pose in target_poses : rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , target_pose . pose . position . x , target_pose . pose . position . y ) get_path_result = get_plan ( target_pose ) if get_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete plan: %s \" , result . message ) return path_goal = create_path_goal ( get_path_result . path , True , 0.5 , 3.14 / 18.0 ) exe_path_result = exe_path ( path_goal ) if exe_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete exe: %s \" , result . message ) return if __name__ == '__main__' : rospy . init_node ( \"move_base_flex_client\" ) # move_base_flex exe path client mbf_ep_ac = actionlib . SimpleActionClient ( \"move_base_flex/exe_path\" , mbf_msgs . ExePathAction ) mbf_ep_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex ExePath server!\" ) # move base flex get path client mbf_gp_ac = actionlib . SimpleActionClient ( \"move_base_flex/get_path\" , mbf_msgs . GetPathAction ) mbf_gp_ac . wait_for_server ( rospy . Duration ( 10 )) drive_circle () rospy . on_shutdown ( lambda : mbf_ep_ac . cancel_all_goals ()) The Code Explained In order to execute a planned path, we need to connect to the proper Action Server: # move_base_flex exe path client mbf_ep_ac = actionlib . SimpleActionClient ( \"move_base_flex/exe_path\" , mbf_msgs . ExePathAction ) mbf_ep_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex ExePath server!\" ) For planning itself, we need to connect to the appropriate Action Server, as well: # move base flex get path client mbf_gp_ac = actionlib . SimpleActionClient ( \"move_base_flex/get_path\" , mbf_msgs . GetPathAction ) mbf_gp_ac . wait_for_server ( rospy . Duration ( 10 )) The main loop handles multiple things: planning a path def get_plan ( pose ): path_goal = mbf_msgs . GetPathGoal ( target_pose = pose , tolerance = 0.5 ) mbf_gp_ac . send_goal ( path_goal ) mbf_gp_ac . wait_for_result () return mbf_gp_ac . get_result () Creating an ExePathGoal def create_path_goal ( path , tolerance_from_action , dist_tolerance , angle_tolerance ): goal = mbf_msgs . ExePathGoal () goal . path = path goal . tolerance_from_action = tolerance_from_action goal . dist_tolerance = dist_tolerance goal . angle_tolerance = angle_tolerance return goal Sending ExePathGoal to the /move_base_flex/exe_path Action Server: def exe_path ( path_goal ): mbf_ep_ac . send_goal ( path_goal ) mbf_ep_ac . wait_for_result () return mbf_ep_ac . get_result () These steps are performed for each target pose: for target_pose in target_poses : rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , target_pose . pose . position . x , target_pose . pose . position . y ) get_path_result = get_plan ( target_pose ) if get_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete plan: %s \" , result . message ) return path_goal = create_path_goal ( get_path_result . path , True , 0.5 , 3.14 / 18.0 ) exe_path_result = exe_path ( path_goal ) if exe_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete exe: %s \" , result . message ) return The full source code can be found here .","title":"Path Planning"},{"location":"tutorials/beginner/path_planning/#path-planning","text":"These tutorials have focused on sending goals to Move Base Flex via its Simple Action Client listening to /move_base_flex/move_base . In many instances, it is helpful to have access to the full planned path, which this tutorial will cover!","title":"Path Planning"},{"location":"tutorials/beginner/path_planning/#code","text":"The turtlebot will drive the same circle as in previous tutorials, but will use the /move_base_flex/exe_path Action Server to execute path goals, and the /move_base_flex/get_path Action Server to plan paths to target poses. import actionlib import rospy import mbf_msgs.msg as mbf_msgs import geometry_msgs.msg as geometry_msgs def create_pose ( x , y , z , xx , yy , zz , ww ): pose = geometry_msgs . PoseStamped () pose . header . frame_id = \"map\" pose . header . stamp = rospy . Time . now () pose . pose . position . x = x pose . pose . position . y = y pose . pose . position . z = z pose . pose . orientation . x = xx pose . pose . orientation . y = yy pose . pose . orientation . z = zz pose . pose . orientation . w = ww return pose def create_path_goal ( path , tolerance_from_action , dist_tolerance , angle_tolerance ): goal = mbf_msgs . ExePathGoal () goal . path = path goal . tolerance_from_action = tolerance_from_action goal . dist_tolerance = dist_tolerance goal . angle_tolerance = angle_tolerance return goal def exe_path ( path_goal ): mbf_ep_ac . send_goal ( path_goal ) mbf_ep_ac . wait_for_result () return mbf_ep_ac . get_result () def get_plan ( pose ): path_goal = mbf_msgs . GetPathGoal ( target_pose = pose , tolerance = 0.5 ) mbf_gp_ac . send_goal ( path_goal ) mbf_gp_ac . wait_for_result () return mbf_gp_ac . get_result () def drive_circle (): target_poses = [ create_pose ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_pose ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), create_pose ( 0.957 , 1.60 , 0 , 0 , 0 , - 0.163 , 0.987 ), create_pose ( 1.8741 , 0.3830 , 0 , 0 , 0 , - 0.70 , 0.711 ), create_pose ( 1.752 , - 0.928 , 0 , 0 , 0 , - 0.856 , 0.517 ), create_pose ( 0.418 , - 2.116 , 0 , 0 , 0 , 0.998 , 0.0619 ), create_pose ( - 0.775 , - 1.80 , 0 , 0 , 0 , 0.954 , 0.300 ), create_pose ( - 1.990 , - 0.508 , 0 , 0 , 0 , - 0.112 , 0.999 ) ] for target_pose in target_poses : rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , target_pose . pose . position . x , target_pose . pose . position . y ) get_path_result = get_plan ( target_pose ) if get_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete plan: %s \" , result . message ) return path_goal = create_path_goal ( get_path_result . path , True , 0.5 , 3.14 / 18.0 ) exe_path_result = exe_path ( path_goal ) if exe_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete exe: %s \" , result . message ) return if __name__ == '__main__' : rospy . init_node ( \"move_base_flex_client\" ) # move_base_flex exe path client mbf_ep_ac = actionlib . SimpleActionClient ( \"move_base_flex/exe_path\" , mbf_msgs . ExePathAction ) mbf_ep_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex ExePath server!\" ) # move base flex get path client mbf_gp_ac = actionlib . SimpleActionClient ( \"move_base_flex/get_path\" , mbf_msgs . GetPathAction ) mbf_gp_ac . wait_for_server ( rospy . Duration ( 10 )) drive_circle () rospy . on_shutdown ( lambda : mbf_ep_ac . cancel_all_goals ())","title":"Code"},{"location":"tutorials/beginner/path_planning/#the-code-explained","text":"In order to execute a planned path, we need to connect to the proper Action Server: # move_base_flex exe path client mbf_ep_ac = actionlib . SimpleActionClient ( \"move_base_flex/exe_path\" , mbf_msgs . ExePathAction ) mbf_ep_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex ExePath server!\" ) For planning itself, we need to connect to the appropriate Action Server, as well: # move base flex get path client mbf_gp_ac = actionlib . SimpleActionClient ( \"move_base_flex/get_path\" , mbf_msgs . GetPathAction ) mbf_gp_ac . wait_for_server ( rospy . Duration ( 10 )) The main loop handles multiple things: planning a path def get_plan ( pose ): path_goal = mbf_msgs . GetPathGoal ( target_pose = pose , tolerance = 0.5 ) mbf_gp_ac . send_goal ( path_goal ) mbf_gp_ac . wait_for_result () return mbf_gp_ac . get_result () Creating an ExePathGoal def create_path_goal ( path , tolerance_from_action , dist_tolerance , angle_tolerance ): goal = mbf_msgs . ExePathGoal () goal . path = path goal . tolerance_from_action = tolerance_from_action goal . dist_tolerance = dist_tolerance goal . angle_tolerance = angle_tolerance return goal Sending ExePathGoal to the /move_base_flex/exe_path Action Server: def exe_path ( path_goal ): mbf_ep_ac . send_goal ( path_goal ) mbf_ep_ac . wait_for_result () return mbf_ep_ac . get_result () These steps are performed for each target pose: for target_pose in target_poses : rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , target_pose . pose . position . x , target_pose . pose . position . y ) get_path_result = get_plan ( target_pose ) if get_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete plan: %s \" , result . message ) return path_goal = create_path_goal ( get_path_result . path , True , 0.5 , 3.14 / 18.0 ) exe_path_result = exe_path ( path_goal ) if exe_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete exe: %s \" , result . message ) return The full source code can be found here .","title":"The Code Explained"},{"location":"tutorials/beginner/welcome/","text":"Beginner Tutorial This tutorial will walk you through a Turlebot Planning Tutorial with the default Navigation Server in a Gazebo simulation environment and will make you familiar with the general planning workflow of using Move Base (Flex) in ROS. Before you continue, make sure to have followed the Installation Instructions and you have a ROS workspace set up mkdir -p ~/catkin_ws/src cd ~/catkin_ws/ catkin_make Topics Basic Navigation Learn how to move a robot from point a to b with Move Base Flex and RViz. Continue here . Beyond the Relay Learn to use the Move Base Flex API directly and leave Move Base behind. Continue here . Path Planning Learn how to plan with pose paths instead of goals for greated flexibility. Continue here Parameters and Configuraton Learn about parameters and configuration of Move Base Flex. Continue here The full source code can be found here .","title":"Welcome"},{"location":"tutorials/beginner/welcome/#beginner-tutorial","text":"This tutorial will walk you through a Turlebot Planning Tutorial with the default Navigation Server in a Gazebo simulation environment and will make you familiar with the general planning workflow of using Move Base (Flex) in ROS. Before you continue, make sure to have followed the Installation Instructions and you have a ROS workspace set up mkdir -p ~/catkin_ws/src cd ~/catkin_ws/ catkin_make","title":"Beginner Tutorial"},{"location":"tutorials/beginner/welcome/#topics","text":"Basic Navigation Learn how to move a robot from point a to b with Move Base Flex and RViz. Continue here . Beyond the Relay Learn to use the Move Base Flex API directly and leave Move Base behind. Continue here . Path Planning Learn how to plan with pose paths instead of goals for greated flexibility. Continue here Parameters and Configuraton Learn about parameters and configuration of Move Base Flex. Continue here The full source code can be found here .","title":"Topics"}]}