{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Move Base Flex (MBF) is an enhanced and highly flexible backwards-compatible replacement for move_base . In Short MBF, first are foremost, provides an enhanced version of the planner, controller and recovery plugin ROS interfaces . It exposes action servers for planning, controlling and recovering, providing detailed information of the current state and the plugin\u2019s feedback. An external executive logic can use MBF and its actions to perform smart and flexible navigation strategies. MBF enables the use of other map representations (besides cost maps), e.g. meshes or grid_map. ROSCon 2017 Publications Move Base Flex: A Highly Flexible Navigation Framework for Mobile Robots @inproceedings { puetz18mbf , author = {Sebastian P\u00fctz and Jorge Santos Sim\u00f3n and Joachim Hertzberg} , title = {{Move Base Flex}: A Highly Flexible Navigation Framework for Mobile Robots} , booktitle = {2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)} , year = 2018 , month = {October} , url = {https://github.com/magazino/move_base_flex} , note = {Software available at \\url{https://github.com/magazino/move_base_flex}} } Continuous Shortest Path Vector Field Navigation on 3D Triangular Meshes for Mobile Robots @inproceedings{puetz21cvp, author = {P\u00fctz, Sebastian and Wiemann, Thomas and Kleine Piening, Malte and Hertzberg, Joachim}, title = {Continuous Shortest Path Vector Field Navigation on 3D Triangular Meshes for Mobile Robots}, booktitle = {2021 IEEE International Conference on Robotics and Automation (ICRA)}, year = 2021, url = {https://github.com/uos/mesh_navigation}, note = {Software available at \\url{https://github.com/uos/mesh_navigation}} } Core Features Fully backwards-compatible with current ROS1 navigation. Actions for the submodules planning, controlling and recovering, and services to query the costmaps are provided. This interface allows external executives, e.g. SMACH, or Behavior Trees, to run highly flexible and complex navigation strategies. Comprehensive result and feedback information on all actions, including error codes and messages from the loaded plugins. For users still relying on a unique navigation interface, we have extended move_base action with detailed result and feedback information (though we still provide the current one). Separation between an abstract navigation framework and concrete implementations, allowing faster development of new applications, e.g. 3D navigation. Load multiple planners and controllers, selectable at runtime by setting one of the loaded plugin names in the action goal. Concurrency: Parallel planning, recovering, controlling by selecting different concurrency slots when defining the action goal. Only different plugins instances can run in parallel. Architecture Details We have created Move Base Flex for a larger target group besides the standard developers and users of move_base and 2D navigation based on costmaps, as well as addressed move_base's limitations. Since robot navigation can be separated into planning and controlling in many cases, even for outdoor scenarios without the benefits of flat terrain, we designed MBF based on abstract planner-, controller- and recovery behavior-execution classes for maximal flexibility . To accomplish this goal, we created abstract base classes for the nav core BaseLocalPlanner, BaseGlobalPlanner and RecoveryBehavior plugin interfaces, extending the API to provide a richer and more expressive interface without breaking the current move_base plugin API. The new abstract interfaces allow plugins to return valuable information in each execution cycle , e.g. why a valid plan or a velocity command could not be computed. This information is then passed to the external executive logic through MBF planning, navigation or recovering actions\u2019 feedback and result. The planner, controller and recovery behavior execution is implemented in the abstract execution classes without binding the software implementation to 2D costmaps (as in move_base). In our framework, move_base is just a particular implementation of a navigation system: its execution classes implement the abstract ones and bind the system to the costmaps. Thereby, the framework can easily be extended for customized navigation approaches , e.g. navigation on meshes or 3D occupancy grid maps. However, we provide a SimpleNavigationServer class without a binding to costmaps. Flowchart Getting Started Follow the MBF Starting Guide and Tutorial See the Move Base Flex Documentation and Tutorials in the ROS wiki. Full code for the showcase and tutorials can be found in this repository .","title":"Home"},{"location":"#_1","text":"Move Base Flex (MBF) is an enhanced and highly flexible backwards-compatible replacement for move_base .","title":""},{"location":"#in-short","text":"MBF, first are foremost, provides an enhanced version of the planner, controller and recovery plugin ROS interfaces . It exposes action servers for planning, controlling and recovering, providing detailed information of the current state and the plugin\u2019s feedback. An external executive logic can use MBF and its actions to perform smart and flexible navigation strategies. MBF enables the use of other map representations (besides cost maps), e.g. meshes or grid_map.","title":"In Short"},{"location":"#roscon-2017","text":"","title":"ROSCon 2017"},{"location":"#publications","text":"Move Base Flex: A Highly Flexible Navigation Framework for Mobile Robots @inproceedings { puetz18mbf , author = {Sebastian P\u00fctz and Jorge Santos Sim\u00f3n and Joachim Hertzberg} , title = {{Move Base Flex}: A Highly Flexible Navigation Framework for Mobile Robots} , booktitle = {2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)} , year = 2018 , month = {October} , url = {https://github.com/magazino/move_base_flex} , note = {Software available at \\url{https://github.com/magazino/move_base_flex}} } Continuous Shortest Path Vector Field Navigation on 3D Triangular Meshes for Mobile Robots @inproceedings{puetz21cvp, author = {P\u00fctz, Sebastian and Wiemann, Thomas and Kleine Piening, Malte and Hertzberg, Joachim}, title = {Continuous Shortest Path Vector Field Navigation on 3D Triangular Meshes for Mobile Robots}, booktitle = {2021 IEEE International Conference on Robotics and Automation (ICRA)}, year = 2021, url = {https://github.com/uos/mesh_navigation}, note = {Software available at \\url{https://github.com/uos/mesh_navigation}} }","title":"Publications"},{"location":"#core-features","text":"Fully backwards-compatible with current ROS1 navigation. Actions for the submodules planning, controlling and recovering, and services to query the costmaps are provided. This interface allows external executives, e.g. SMACH, or Behavior Trees, to run highly flexible and complex navigation strategies. Comprehensive result and feedback information on all actions, including error codes and messages from the loaded plugins. For users still relying on a unique navigation interface, we have extended move_base action with detailed result and feedback information (though we still provide the current one). Separation between an abstract navigation framework and concrete implementations, allowing faster development of new applications, e.g. 3D navigation. Load multiple planners and controllers, selectable at runtime by setting one of the loaded plugin names in the action goal. Concurrency: Parallel planning, recovering, controlling by selecting different concurrency slots when defining the action goal. Only different plugins instances can run in parallel.","title":"Core Features"},{"location":"#architecture-details","text":"We have created Move Base Flex for a larger target group besides the standard developers and users of move_base and 2D navigation based on costmaps, as well as addressed move_base's limitations. Since robot navigation can be separated into planning and controlling in many cases, even for outdoor scenarios without the benefits of flat terrain, we designed MBF based on abstract planner-, controller- and recovery behavior-execution classes for maximal flexibility . To accomplish this goal, we created abstract base classes for the nav core BaseLocalPlanner, BaseGlobalPlanner and RecoveryBehavior plugin interfaces, extending the API to provide a richer and more expressive interface without breaking the current move_base plugin API. The new abstract interfaces allow plugins to return valuable information in each execution cycle , e.g. why a valid plan or a velocity command could not be computed. This information is then passed to the external executive logic through MBF planning, navigation or recovering actions\u2019 feedback and result. The planner, controller and recovery behavior execution is implemented in the abstract execution classes without binding the software implementation to 2D costmaps (as in move_base). In our framework, move_base is just a particular implementation of a navigation system: its execution classes implement the abstract ones and bind the system to the costmaps. Thereby, the framework can easily be extended for customized navigation approaches , e.g. navigation on meshes or 3D occupancy grid maps. However, we provide a SimpleNavigationServer class without a binding to costmaps.","title":"Architecture Details"},{"location":"#flowchart","text":"","title":"Flowchart"},{"location":"#getting-started","text":"Follow the MBF Starting Guide and Tutorial See the Move Base Flex Documentation and Tutorials in the ROS wiki. Full code for the showcase and tutorials can be found in this repository .","title":"Getting Started"},{"location":"installation/","text":"Installation Supported platforms are ROS Kinetic, Melodic and Noetic ( Build Status ) The following packages must be installed to use Move Base Flex: ROS Kinetic+. Please follow the official installation guide for your distro . Don't forget setting up rosdep . Move Base Flex: For Use: apt install ros-$ROS_VERSION-move-base-flex For Development: clone the official move_base_flex repo into your catkin workspace At this point, you are ready for your first tutorial .","title":"Installation"},{"location":"installation/#installation","text":"Supported platforms are ROS Kinetic, Melodic and Noetic ( Build Status ) The following packages must be installed to use Move Base Flex: ROS Kinetic+. Please follow the official installation guide for your distro . Don't forget setting up rosdep . Move Base Flex: For Use: apt install ros-$ROS_VERSION-move-base-flex For Development: clone the official move_base_flex repo into your catkin workspace At this point, you are ready for your first tutorial .","title":"Installation"},{"location":"showcase/","text":"MBF showcase Navigation on 3D Meshes TODO Source: uos/mesh_navigation Default \"SimpleNavigationServer\" Navigation TODO","title":"Showcase"},{"location":"showcase/#mbf-showcase","text":"","title":"MBF showcase"},{"location":"showcase/#navigation-on-3d-meshes","text":"TODO Source: uos/mesh_navigation","title":"Navigation on 3D Meshes"},{"location":"showcase/#default-simplenavigationserver-navigation","text":"TODO","title":"Default \"SimpleNavigationServer\" Navigation"},{"location":"concepts/concepts/","text":"Concepts Actionlib: Action Servers and Clients Actionlib is a built-in ROS package and provides a standardized interfaces for working with preemptible tasks and is a central piece of communicating Typically, a client will request some task to be completed on the server. Because this action will complete at some time in the future, feedback that the client can receive during execution can be anything and is defined in the corresponding ROS .action . This architecture is flexible in the sense that the client can chose to block or poll the server, until the goal is reached. In Move Base Flex, for example, the mbf_msgs/MoveBaseAction provides the distance to the goal, angle to the goal, current pose and last command calculated by the controller to the client during path execution. The official tutorials are a good place to get started. Environment Representation Costmap The default environmental representation of Move Base Flex is a costmap, which is a regular 2D grid of cells representing an occupancy grid of the sensor data. A cells state can generally known to be unknown , free or occupied by an obstacle. Costmaps can be created from LIDAR, RADAR, sonar, (depth) images and more. Others Many different environment represetations exist, e.g. 3D costmap: represents planning space in 3D Mesh maps: the planning space is represented with a surface mesh. You can see a mesh navigation plugin for Move Base Flex here . Gradient maps: Typically used for traversibility tasks as surface is represented as gradients Planners, Controllers, Recovery Behavior Planners The general task for a planner is to compute a valid and potentially optimal path from the current pose to a goal pose. For this, the planner has access to a global environment representation and sensor data (IMU, Lidar, etc). The default global planner in the ROS1 Navigation Stack is navfn/NavfnROS . Controller A controller, also referred to as local planner in the ROS1 navigation stack, computes how to follow the global path provided by a global Planner by generating control signals. Many different controllers exist, that implement different features. Some popular local planners/controllers in the ROS1 navigation ecosystem are dwa_local_planner/DWALocalPlannerROS eband_local_planner/EBandPlannerROS Recovery Behavior TODO ADVANCED TUTORIAL","title":"Concepts"},{"location":"concepts/concepts/#concepts","text":"","title":"Concepts"},{"location":"concepts/concepts/#actionlib-action-servers-and-clients","text":"Actionlib is a built-in ROS package and provides a standardized interfaces for working with preemptible tasks and is a central piece of communicating Typically, a client will request some task to be completed on the server. Because this action will complete at some time in the future, feedback that the client can receive during execution can be anything and is defined in the corresponding ROS .action . This architecture is flexible in the sense that the client can chose to block or poll the server, until the goal is reached. In Move Base Flex, for example, the mbf_msgs/MoveBaseAction provides the distance to the goal, angle to the goal, current pose and last command calculated by the controller to the client during path execution. The official tutorials are a good place to get started.","title":"Actionlib: Action Servers and Clients"},{"location":"concepts/concepts/#environment-representation","text":"","title":"Environment Representation"},{"location":"concepts/concepts/#costmap","text":"The default environmental representation of Move Base Flex is a costmap, which is a regular 2D grid of cells representing an occupancy grid of the sensor data. A cells state can generally known to be unknown , free or occupied by an obstacle. Costmaps can be created from LIDAR, RADAR, sonar, (depth) images and more.","title":"Costmap"},{"location":"concepts/concepts/#others","text":"Many different environment represetations exist, e.g. 3D costmap: represents planning space in 3D Mesh maps: the planning space is represented with a surface mesh. You can see a mesh navigation plugin for Move Base Flex here . Gradient maps: Typically used for traversibility tasks as surface is represented as gradients","title":"Others"},{"location":"concepts/concepts/#planners-controllers-recovery-behavior","text":"","title":"Planners, Controllers, Recovery Behavior"},{"location":"concepts/concepts/#planners","text":"The general task for a planner is to compute a valid and potentially optimal path from the current pose to a goal pose. For this, the planner has access to a global environment representation and sensor data (IMU, Lidar, etc). The default global planner in the ROS1 Navigation Stack is navfn/NavfnROS .","title":"Planners"},{"location":"concepts/concepts/#controller","text":"A controller, also referred to as local planner in the ROS1 navigation stack, computes how to follow the global path provided by a global Planner by generating control signals. Many different controllers exist, that implement different features. Some popular local planners/controllers in the ROS1 navigation ecosystem are dwa_local_planner/DWALocalPlannerROS eband_local_planner/EBandPlannerROS","title":"Controller"},{"location":"concepts/concepts/#recovery-behavior","text":"TODO ADVANCED TUTORIAL","title":"Recovery Behavior"},{"location":"tutorials/mesh_navigation_stack/","text":"Mesh Navigation Stack TODO","title":"Mesh Navigation Stack"},{"location":"tutorials/mesh_navigation_stack/#mesh-navigation-stack","text":"TODO","title":"Mesh Navigation Stack"},{"location":"tutorials/overview/","text":"Welcome Welcome to the Move Base Flex Tutorials. Before you continue, make sure to have followed the Installation Instructions Tutorials Beginner Introduction to the ROS planning stack with Move Base (Flex) and a Turtlebot in Gazebo. Learn about Move Base and its configuration to send your robot to the requested location write a simple SMACH. Continue here Advanced The advanced tutorial will teach you the use of different Controllers and Planners at Runtime implementing intelligent Recovery Behavior Handling Continous Replanning Concurrency Slots for Simultaneous Replanning Continue here Expert Multi Robot Navigation with one Move Base Flex Instance. Continue here TODO Writing Move Base Flex Plugins TODO Mesh Navigation Stack TODO","title":"Tutorials"},{"location":"tutorials/overview/#welcome","text":"Welcome to the Move Base Flex Tutorials. Before you continue, make sure to have followed the Installation Instructions","title":"Welcome"},{"location":"tutorials/overview/#tutorials","text":"Beginner Introduction to the ROS planning stack with Move Base (Flex) and a Turtlebot in Gazebo. Learn about Move Base and its configuration to send your robot to the requested location write a simple SMACH. Continue here Advanced The advanced tutorial will teach you the use of different Controllers and Planners at Runtime implementing intelligent Recovery Behavior Handling Continous Replanning Concurrency Slots for Simultaneous Replanning Continue here Expert Multi Robot Navigation with one Move Base Flex Instance. Continue here TODO Writing Move Base Flex Plugins TODO Mesh Navigation Stack TODO","title":"Tutorials"},{"location":"tutorials/writing_mbf_plugins/","text":"Writing Move Base Flex Plugins TODO","title":"Writing MBF Plugins"},{"location":"tutorials/writing_mbf_plugins/#writing-move-base-flex-plugins","text":"TODO","title":"Writing Move Base Flex Plugins"},{"location":"tutorials/advanced/behavior_tree/","text":"Behavior Trees Behavior Trees are an interesting alternative to State Machines. Actions between states in a SMACH become leaves in a tree, and moving between states in a SMACH is handles by the root of the tree in Behavior Tree based planning. For more details, visit this overview . We will use a Behavior Tree based on the BehaviorTree.CPP library to implement the following algorithm: You could express the tree in the following way: First, drive Home. Once you've reached home, repeat: Attempt to move to next goal If that fails, attempt to skip to next goal. If that fails, attempt to move back. If that fails, attempt to skip over the move back. When all of that fails (because we reached end of circle, or fatal planner error), force BT to go drive Home (ForceSucess) It is important to understand that this fallback behavior is implemented separately from the Move Base Flex recovery plugin infrastructure covered in the previous tutorial . The Code #include <fstream> #include <ros/ros.h> #include <behaviortree_cpp_v3/bt_factory.h> #include <mbf_advanced/mbf_circle_client.h> using State = mbf_advanced :: MBFCircleClientState ; BT :: NodeStatus DriveHome ( std :: shared_ptr < mbf_advanced :: MBFCircleClient >& mbfclient ) { ROS_INFO_STREAM ( \"BT: driving home\" ); return mbfclient -> driveHome () ? BT :: NodeStatus :: SUCCESS : BT :: NodeStatus :: FAILURE ; } class AttemptNext : public BT :: SyncActionNode { public : explicit AttemptNext ( const std :: string & name ) : BT :: SyncActionNode ( name , {}) , mbfclient_ {} { } void attachMBFClient ( std :: shared_ptr < mbf_advanced :: MBFCircleClient > mbfclient ) { mbfclient_ = mbfclient ; } BT :: NodeStatus tick () override { if ( mbfclient_ ) { ROS_INFO_STREAM ( \"BT: \" << this -> name ()); while ( mbfclient_ -> next_move () == State :: MOVING ) {} return BT :: NodeStatus :: FAILURE ; } return BT :: NodeStatus :: FAILURE ; } private : std :: shared_ptr < mbf_advanced :: MBFCircleClient > mbfclient_ ; }; class AttemptSkip : public BT :: SyncActionNode { public : explicit AttemptSkip ( const std :: string & name ) : BT :: SyncActionNode ( name , {}) , mbfclient_ {} { } void attachMBFClient ( std :: shared_ptr < mbf_advanced :: MBFCircleClient > mbfclient ) { mbfclient_ = mbfclient ; } BT :: NodeStatus tick () override { if ( mbfclient_ ) { ROS_INFO_STREAM ( \"BT: \" << this -> name ()); return ( mbfclient_ -> next_move () == State :: MOVING ) ? BT :: NodeStatus :: SUCCESS : BT :: NodeStatus :: FAILURE ; } return BT :: NodeStatus :: FAILURE ; } private : std :: shared_ptr < mbf_advanced :: MBFCircleClient > mbfclient_ ; }; class AttemptPrevious : public BT :: SyncActionNode { public : AttemptPrevious ( const std :: string & name ) : SyncActionNode ( name , {}) , mbfclient_ {} { } void attachMBFClient ( std :: shared_ptr < mbf_advanced :: MBFCircleClient > mbfclient ) { mbfclient_ = mbfclient ; } BT :: NodeStatus tick () override { if ( mbfclient_ ) { ROS_INFO_STREAM ( \"BT: \" << this -> name ()); return ( mbfclient_ -> prev_move () == State :: MOVING ) ? BT :: NodeStatus :: SUCCESS : BT :: NodeStatus :: FAILURE ; } return BT :: NodeStatus :: FAILURE ; } private : std :: shared_ptr < mbf_advanced :: MBFCircleClient > mbfclient_ ; }; int main ( int argc , char ** argv ) { ros :: init ( argc , argv , \"behavior_tree\" ); ros :: NodeHandle n ; auto mbfclient = std :: make_shared < mbf_advanced :: MBFCircleClient > ( std :: move ( mbf_advanced :: loadPoseGoals ( POSE_PATH ))); BT :: BehaviorTreeFactory factory ; factory . registerSimpleCondition ( \"DriveHomeStart\" , std :: bind ( DriveHome , std :: ref ( mbfclient ))); factory . registerNodeType < AttemptNext > ( \"AttemptNext\" ); factory . registerNodeType < AttemptSkip > ( \"AttemptSkip\" ); factory . registerNodeType < AttemptPrevious > ( \"AttemptPrevious\" ); factory . registerNodeType < AttemptPrevious > ( \"AttemptSkipPrevious\" ); factory . registerSimpleCondition ( \"DriveHomeEnd\" , std :: bind ( DriveHome , std :: ref ( mbfclient ))); auto tree = factory . createTreeFromFile ( BT_XML_PATH ); for ( auto & node : tree . nodes ) { if ( auto attempt_next = dynamic_cast < AttemptNext *> ( node . get () )) { attempt_next -> attachMBFClient ( mbfclient ); } if ( auto attempt_skip = dynamic_cast < AttemptSkip *> ( node . get () )) { attempt_skip -> attachMBFClient ( mbfclient ); } if ( auto attempt_prev = dynamic_cast < AttemptPrevious *> ( node . get () )) { attempt_prev -> attachMBFClient ( mbfclient ); } } tree . tickRoot (); return 0 ; } and the corresponding .xml file that specifies the relations between each node <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"endless_circle\" > <DriveHomeStart name= \"drive_home_start\" /> <ForceSuccess> <Repeat num_cycles= \"10\" > <Fallback> <AttemptNext name= \"attempt_next\" /> <AttemptSkip name= \"attempt_skip\" /> <AttemptPrevious name= \"attempt_previous\" /> <AttemptSkipPrevious name= \"attempt_skip_previous\" /> </Fallback> </Repeat> </ForceSuccess> <DriveHomeEnd name= \"drive_home_end\" /> </Sequence> </BehaviorTree> </root> What isn't shown here is the mbf_advanced::MBFClient : it is a C++ node that communicated with the Move Base Flex Action server to retrieve plans (next and previous), very similar to the previous tutorials. The full code for this client can be found here . The Code explained First, we want to drive \"Home\" a.k.a to the robots spawn position. This is done with a simple condition, that returns BT::NodeStates::SUCCESS if that happened successfully BT :: NodeStatus DriveHome ( std :: shared_ptr < mbf_advanced :: MBFClient >& mbfclient ) { ROS_INFO_STREAM ( \"BT: driving home\" ); return mbfclient -> driveHome () ? BT :: NodeStatus :: SUCCESS : BT :: NodeStatus :: FAILURE ; } The Fallback node of the tree performs exactly one of the actions AttemptNext or AttemptPrevious and attempts each from left to right in the tree. AttemptNext performs the planning of the next goal on each tick() and only returns BT::NodeStatus::Failure when the plan fails or we've reached the end of the circle. BT :: NodeStatus tick () override { if ( mbfclient_ ) { ROS_INFO_STREAM ( \"BT: \" << this -> name ()); while ( mbfclient_ -> next_move () == State :: MOVING ) {} return BT :: NodeStatus :: FAILURE ; } return BT :: NodeStatus :: FAILURE ; } AttemptSkip is very similar to AttemptNext , but is only called after a failed AttemptNext and therefore skips to next point in circle. BT :: NodeStatus tick () override { if ( mbfclient_ ) { ROS_INFO_STREAM ( \"BT: \" << this -> name ()); return ( mbfclient_ -> next_move () == State :: MOVING ) ? BT :: NodeStatus :: SUCCESS : BT :: NodeStatus :: FAILURE ; } return BT :: NodeStatus :: FAILURE ; } AttemptPrevious attempts to return to the previous state and returns a BT::NodeStatus::Failure if that fails or we've reached the end of the circle: BT :: NodeStatus tick () override { if ( mbfclient_ ) { ROS_INFO_STREAM ( \"BT: \" << this -> name ()); return ( mbfclient_ -> prev_move () == State :: MOVING ) ? BT :: NodeStatus :: SUCCESS : BT :: NodeStatus :: FAILURE ; } return BT :: NodeStatus :: FAILURE ; } When all Fallback options fail we want to return \"Home\" again. This happens after a fatal planning error or after reaching the end of the circle pose queue. By forcing the Fallback node to return Success in the xml with ForceSuccess <ForceSuccess> <Repeat num_cycles= \"-1\" > <Fallback> <AttemptNext name= \"attempt_next\" /> ... </Fallback> </Repeat> </ForceSuccess> the BT reaches the last state: drive Home. BT :: NodeStatus DriveHome ( std :: shared_ptr < mbf_advanced :: MBFCircleClient >& mbfclient ) { ROS_INFO_STREAM ( \"BT: driving home\" ); return mbfclient -> driveHome () ? BT :: NodeStatus :: SUCCESS : BT :: NodeStatus :: FAILURE ; } Try it yourself Recovery Please note that the recovery behaviors from the previous tutorial are explicitely disabled to make it easier for you to produce a planner error! Launch the gazebo world for turtlebot: export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch Launch Move Base Flex w/o recovery mode: export TURTLEBOT3_MODEL = burger roslaunch mbf_advanced amcl_demo_mbf.launch Launch the behavior tree roslaunch mbf_advanced mbf_behavior_tree If you want, you can try to produce fatal plans with the help of an additional square in the Gazebo world: roslaunch mbf_advanced spawn_box.launch Choose the object move mode in gazebo and place the square somewhere into the path of the robot, and whatch RViz! Wrapping up You may have noticed that this BT uses high level actions (drive to goal, drive home) in its leaves. Because BTs are so flexible, you could also use lower level actions in its leaves: a sequence like NewGoal , ClearGoal , GetPath , ExePath and Recovery . We'll do this in our next tutorial based on py_trees_ros .","title":"Behavior Tree (C++)"},{"location":"tutorials/advanced/behavior_tree/#behavior-trees","text":"Behavior Trees are an interesting alternative to State Machines. Actions between states in a SMACH become leaves in a tree, and moving between states in a SMACH is handles by the root of the tree in Behavior Tree based planning. For more details, visit this overview . We will use a Behavior Tree based on the BehaviorTree.CPP library to implement the following algorithm: You could express the tree in the following way: First, drive Home. Once you've reached home, repeat: Attempt to move to next goal If that fails, attempt to skip to next goal. If that fails, attempt to move back. If that fails, attempt to skip over the move back. When all of that fails (because we reached end of circle, or fatal planner error), force BT to go drive Home (ForceSucess) It is important to understand that this fallback behavior is implemented separately from the Move Base Flex recovery plugin infrastructure covered in the previous tutorial .","title":"Behavior Trees"},{"location":"tutorials/advanced/behavior_tree/#the-code","text":"#include <fstream> #include <ros/ros.h> #include <behaviortree_cpp_v3/bt_factory.h> #include <mbf_advanced/mbf_circle_client.h> using State = mbf_advanced :: MBFCircleClientState ; BT :: NodeStatus DriveHome ( std :: shared_ptr < mbf_advanced :: MBFCircleClient >& mbfclient ) { ROS_INFO_STREAM ( \"BT: driving home\" ); return mbfclient -> driveHome () ? BT :: NodeStatus :: SUCCESS : BT :: NodeStatus :: FAILURE ; } class AttemptNext : public BT :: SyncActionNode { public : explicit AttemptNext ( const std :: string & name ) : BT :: SyncActionNode ( name , {}) , mbfclient_ {} { } void attachMBFClient ( std :: shared_ptr < mbf_advanced :: MBFCircleClient > mbfclient ) { mbfclient_ = mbfclient ; } BT :: NodeStatus tick () override { if ( mbfclient_ ) { ROS_INFO_STREAM ( \"BT: \" << this -> name ()); while ( mbfclient_ -> next_move () == State :: MOVING ) {} return BT :: NodeStatus :: FAILURE ; } return BT :: NodeStatus :: FAILURE ; } private : std :: shared_ptr < mbf_advanced :: MBFCircleClient > mbfclient_ ; }; class AttemptSkip : public BT :: SyncActionNode { public : explicit AttemptSkip ( const std :: string & name ) : BT :: SyncActionNode ( name , {}) , mbfclient_ {} { } void attachMBFClient ( std :: shared_ptr < mbf_advanced :: MBFCircleClient > mbfclient ) { mbfclient_ = mbfclient ; } BT :: NodeStatus tick () override { if ( mbfclient_ ) { ROS_INFO_STREAM ( \"BT: \" << this -> name ()); return ( mbfclient_ -> next_move () == State :: MOVING ) ? BT :: NodeStatus :: SUCCESS : BT :: NodeStatus :: FAILURE ; } return BT :: NodeStatus :: FAILURE ; } private : std :: shared_ptr < mbf_advanced :: MBFCircleClient > mbfclient_ ; }; class AttemptPrevious : public BT :: SyncActionNode { public : AttemptPrevious ( const std :: string & name ) : SyncActionNode ( name , {}) , mbfclient_ {} { } void attachMBFClient ( std :: shared_ptr < mbf_advanced :: MBFCircleClient > mbfclient ) { mbfclient_ = mbfclient ; } BT :: NodeStatus tick () override { if ( mbfclient_ ) { ROS_INFO_STREAM ( \"BT: \" << this -> name ()); return ( mbfclient_ -> prev_move () == State :: MOVING ) ? BT :: NodeStatus :: SUCCESS : BT :: NodeStatus :: FAILURE ; } return BT :: NodeStatus :: FAILURE ; } private : std :: shared_ptr < mbf_advanced :: MBFCircleClient > mbfclient_ ; }; int main ( int argc , char ** argv ) { ros :: init ( argc , argv , \"behavior_tree\" ); ros :: NodeHandle n ; auto mbfclient = std :: make_shared < mbf_advanced :: MBFCircleClient > ( std :: move ( mbf_advanced :: loadPoseGoals ( POSE_PATH ))); BT :: BehaviorTreeFactory factory ; factory . registerSimpleCondition ( \"DriveHomeStart\" , std :: bind ( DriveHome , std :: ref ( mbfclient ))); factory . registerNodeType < AttemptNext > ( \"AttemptNext\" ); factory . registerNodeType < AttemptSkip > ( \"AttemptSkip\" ); factory . registerNodeType < AttemptPrevious > ( \"AttemptPrevious\" ); factory . registerNodeType < AttemptPrevious > ( \"AttemptSkipPrevious\" ); factory . registerSimpleCondition ( \"DriveHomeEnd\" , std :: bind ( DriveHome , std :: ref ( mbfclient ))); auto tree = factory . createTreeFromFile ( BT_XML_PATH ); for ( auto & node : tree . nodes ) { if ( auto attempt_next = dynamic_cast < AttemptNext *> ( node . get () )) { attempt_next -> attachMBFClient ( mbfclient ); } if ( auto attempt_skip = dynamic_cast < AttemptSkip *> ( node . get () )) { attempt_skip -> attachMBFClient ( mbfclient ); } if ( auto attempt_prev = dynamic_cast < AttemptPrevious *> ( node . get () )) { attempt_prev -> attachMBFClient ( mbfclient ); } } tree . tickRoot (); return 0 ; } and the corresponding .xml file that specifies the relations between each node <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"endless_circle\" > <DriveHomeStart name= \"drive_home_start\" /> <ForceSuccess> <Repeat num_cycles= \"10\" > <Fallback> <AttemptNext name= \"attempt_next\" /> <AttemptSkip name= \"attempt_skip\" /> <AttemptPrevious name= \"attempt_previous\" /> <AttemptSkipPrevious name= \"attempt_skip_previous\" /> </Fallback> </Repeat> </ForceSuccess> <DriveHomeEnd name= \"drive_home_end\" /> </Sequence> </BehaviorTree> </root> What isn't shown here is the mbf_advanced::MBFClient : it is a C++ node that communicated with the Move Base Flex Action server to retrieve plans (next and previous), very similar to the previous tutorials. The full code for this client can be found here .","title":"The Code"},{"location":"tutorials/advanced/behavior_tree/#the-code-explained","text":"First, we want to drive \"Home\" a.k.a to the robots spawn position. This is done with a simple condition, that returns BT::NodeStates::SUCCESS if that happened successfully BT :: NodeStatus DriveHome ( std :: shared_ptr < mbf_advanced :: MBFClient >& mbfclient ) { ROS_INFO_STREAM ( \"BT: driving home\" ); return mbfclient -> driveHome () ? BT :: NodeStatus :: SUCCESS : BT :: NodeStatus :: FAILURE ; } The Fallback node of the tree performs exactly one of the actions AttemptNext or AttemptPrevious and attempts each from left to right in the tree. AttemptNext performs the planning of the next goal on each tick() and only returns BT::NodeStatus::Failure when the plan fails or we've reached the end of the circle. BT :: NodeStatus tick () override { if ( mbfclient_ ) { ROS_INFO_STREAM ( \"BT: \" << this -> name ()); while ( mbfclient_ -> next_move () == State :: MOVING ) {} return BT :: NodeStatus :: FAILURE ; } return BT :: NodeStatus :: FAILURE ; } AttemptSkip is very similar to AttemptNext , but is only called after a failed AttemptNext and therefore skips to next point in circle. BT :: NodeStatus tick () override { if ( mbfclient_ ) { ROS_INFO_STREAM ( \"BT: \" << this -> name ()); return ( mbfclient_ -> next_move () == State :: MOVING ) ? BT :: NodeStatus :: SUCCESS : BT :: NodeStatus :: FAILURE ; } return BT :: NodeStatus :: FAILURE ; } AttemptPrevious attempts to return to the previous state and returns a BT::NodeStatus::Failure if that fails or we've reached the end of the circle: BT :: NodeStatus tick () override { if ( mbfclient_ ) { ROS_INFO_STREAM ( \"BT: \" << this -> name ()); return ( mbfclient_ -> prev_move () == State :: MOVING ) ? BT :: NodeStatus :: SUCCESS : BT :: NodeStatus :: FAILURE ; } return BT :: NodeStatus :: FAILURE ; } When all Fallback options fail we want to return \"Home\" again. This happens after a fatal planning error or after reaching the end of the circle pose queue. By forcing the Fallback node to return Success in the xml with ForceSuccess <ForceSuccess> <Repeat num_cycles= \"-1\" > <Fallback> <AttemptNext name= \"attempt_next\" /> ... </Fallback> </Repeat> </ForceSuccess> the BT reaches the last state: drive Home. BT :: NodeStatus DriveHome ( std :: shared_ptr < mbf_advanced :: MBFCircleClient >& mbfclient ) { ROS_INFO_STREAM ( \"BT: driving home\" ); return mbfclient -> driveHome () ? BT :: NodeStatus :: SUCCESS : BT :: NodeStatus :: FAILURE ; }","title":"The Code explained"},{"location":"tutorials/advanced/behavior_tree/#try-it-yourself","text":"Recovery Please note that the recovery behaviors from the previous tutorial are explicitely disabled to make it easier for you to produce a planner error! Launch the gazebo world for turtlebot: export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch Launch Move Base Flex w/o recovery mode: export TURTLEBOT3_MODEL = burger roslaunch mbf_advanced amcl_demo_mbf.launch Launch the behavior tree roslaunch mbf_advanced mbf_behavior_tree If you want, you can try to produce fatal plans with the help of an additional square in the Gazebo world: roslaunch mbf_advanced spawn_box.launch Choose the object move mode in gazebo and place the square somewhere into the path of the robot, and whatch RViz!","title":"Try it yourself"},{"location":"tutorials/advanced/behavior_tree/#wrapping-up","text":"You may have noticed that this BT uses high level actions (drive to goal, drive home) in its leaves. Because BTs are so flexible, you could also use lower level actions in its leaves: a sequence like NewGoal , ClearGoal , GetPath , ExePath and Recovery . We'll do this in our next tutorial based on py_trees_ros .","title":"Wrapping up"},{"location":"tutorials/advanced/continuous_replanning/","text":"Continuous Replanning WIP Up to this point in the MBF Tutorials the general planning flow has been to generate a global plan to the target once, and handing over the path to the local planner/controller to execute the plan. This behavior is inherently unable to handle dynamic changes to the environment the robot is in: After a certain amount of necessary change to the global plan, the local_planner/controller will fail. The amount of change that the navigation stack can handle is highly dependent on the specific controller. This is were continuous replanning comes into play: To make the local planners life easier, we will use the globbal planner to replan from the current state in continous intervals. mbf_msgs/MoveBaseAction Move Base Flex has continuous replanning built into the mbf_msgs/MoveBaseAction ROS service call, which makes continuous replanning in simple dynamic environments very easy!","title":"Continuous Replanning"},{"location":"tutorials/advanced/continuous_replanning/#continuous-replanning","text":"WIP Up to this point in the MBF Tutorials the general planning flow has been to generate a global plan to the target once, and handing over the path to the local planner/controller to execute the plan. This behavior is inherently unable to handle dynamic changes to the environment the robot is in: After a certain amount of necessary change to the global plan, the local_planner/controller will fail. The amount of change that the navigation stack can handle is highly dependent on the specific controller. This is were continuous replanning comes into play: To make the local planners life easier, we will use the globbal planner to replan from the current state in continous intervals.","title":"Continuous Replanning"},{"location":"tutorials/advanced/continuous_replanning/#mbf_msgsmovebaseaction","text":"Move Base Flex has continuous replanning built into the mbf_msgs/MoveBaseAction ROS service call, which makes continuous replanning in simple dynamic environments very easy!","title":"mbf_msgs/MoveBaseAction"},{"location":"tutorials/advanced/overview/","text":"Advanced Tutorials After following the beginner tutorials, the following tutorials are meant to teach you how to implement comprehensive plans that include, among other things, recovery behaviors to enable you to use Move Base Flex in the real world. Topics State Machine (SMACH) (Python) Write you first state machine for the circle example you are familiar with. Continue here . Continuous Replanning Learn to use Move Base Flex to your advantage and continously replan around dynamic obstacles. Continue here . Recovery Behavior : Explore options to recover from fatal states during the plans execution. Continue here . Behavior Tree (C++) You will learn to implement a simple Behavior Tree, an alternative planning approach to State Machines. Continue here . Behavior Tree (Python) Not ready to use C++? Follow this tutorials to learn to write a simple Behavior Tree in C++. Continue here .","title":"Overview"},{"location":"tutorials/advanced/overview/#advanced-tutorials","text":"After following the beginner tutorials, the following tutorials are meant to teach you how to implement comprehensive plans that include, among other things, recovery behaviors to enable you to use Move Base Flex in the real world.","title":"Advanced Tutorials"},{"location":"tutorials/advanced/overview/#topics","text":"State Machine (SMACH) (Python) Write you first state machine for the circle example you are familiar with. Continue here . Continuous Replanning Learn to use Move Base Flex to your advantage and continously replan around dynamic obstacles. Continue here . Recovery Behavior : Explore options to recover from fatal states during the plans execution. Continue here . Behavior Tree (C++) You will learn to implement a simple Behavior Tree, an alternative planning approach to State Machines. Continue here . Behavior Tree (Python) Not ready to use C++? Follow this tutorials to learn to write a simple Behavior Tree in C++. Continue here .","title":"Topics"},{"location":"tutorials/advanced/pytrees/","text":"PyTrees Move Base Flex Tutorial (Python) py_trees_ros is a Python-based behavior tree implementation and may be easier for you to use, depending on your background. If you are looking for C++ based Behavior Trees, try the previous tutorial What you will learn In this tutorial we address the actions GetPath , ExePath and Recovery provided by Move Base Flex. While GetPath runs the global planner searching for a path to the target pose, ExePath runs the local planner executing the planned path. The Recovery action can be used to execute various behaviors for error handling during planning and controlling. We connect these actions by setting up a py_trees_ros Behavior Tree (BT from now on) using ActionClient Behaviors. In addition to the actions described above, the implementation of a state that receives a navigation goal by the user is required. The target pose can be easily set via the visualization tool RViz and published on a specific topic. This tutorial very closely follows the ROS Wiki . PyTrees To learn about BTs and the particular library used here I encourage you to read py-trees documentation , and follow py_trees_ros tutorials to learn how to control ROS-based robots with BTs. As a minimum requirement to understand what's coming next, be sure you understand the following concepts: action behavior check behavior composite blackboard The Code \"\"\" MBF BT Demo: Behavior tree implementing a really basic navigation strategy, even simpler than the move_base hardcoded FSM, as it lacks: * continuous replanning * oscillation detection We create on the first place action client behaviors for MBF's planner, controller and recovery action servers On this simple demo we need to add pretty little additional code to the base ActionClient class \"\"\" ############################################################################## # Imports ############################################################################## import functools import py_trees import py_trees_ros import py_trees.console as console import rospy import sys import geometry_msgs.msg as geometry_msgs import mbf_msgs.msg as mbf_msgs ############################################################################## # Actions ############################################################################## class GetPath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): \"\"\" Get target pose from the blackboard to create an action goal \"\"\" self . action_goal = mbf_msgs . GetPathGoal ( target_pose = py_trees . blackboard . Blackboard () . get ( \"target_pose\" )) super ( GetPath , self ) . initialise () def update ( self ): \"\"\" On success, set the resulting path on the blackboard, so ExePath can use it \"\"\" status = super ( GetPath , self ) . update () if status == py_trees . Status . SUCCESS : py_trees . blackboard . Blackboard () . set ( \"path\" , self . action_client . get_result () . path ) return status class ExePath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): \"\"\" Get path from the blackboard to create an action goal \"\"\" self . action_goal = mbf_msgs . ExePathGoal ( path = py_trees . blackboard . Blackboard () . get ( \"path\" )) super ( ExePath , self ) . initialise () class Recovery ( py_trees_ros . actions . ActionClient ): def setup ( self , timeout ): \"\"\" Read the list of available recovery behaviors so we can try them in sequence \"\"\" self . _behaviors = rospy . get_param ( \"/move_base_flex/recovery_behaviors\" ) return super ( Recovery , self ) . setup ( timeout ) def update ( self ): \"\"\" Try the next recovery behavior, dropping it from the list \"\"\" try : self . action_goal = mbf_msgs . RecoveryGoal ( behavior = self . _behaviors . pop ( 0 )[ \"name\" ]) return super ( Recovery , self ) . update () except IndexError : # recovery behaviors exhausted; fail to abort navigation but restore the list for the next goal # TODO: this means that we won't reset the list after a successful recovery, so the list keeps shrinking # until fully exhausted; that's clearly not the expected operation, so I need to find a better solution self . _behaviors = rospy . get_param ( \"/move_base_flex/recovery_behaviors\" ) return py_trees . Status . FAILURE ############################################################################## # Behaviours ############################################################################## def create_root (): # Create all behaviours bt_root = py_trees . composites . Sequence ( \"MBF BT Demo\" ) get_goal = py_trees . composites . Selector ( \"GetGoal\" ) fallback = py_trees . composites . Selector ( \"Fallback\" ) navigate = py_trees . composites . Sequence ( \"Navigate\" ) new_goal = py_trees_ros . subscribers . ToBlackboard ( name = \"NewGoal\" , topic_name = \"/move_base_simple/goal\" , topic_type = geometry_msgs . PoseStamped , blackboard_variables = { 'target_pose' : None }) have_goal = py_trees . blackboard . CheckBlackboardVariable ( name = \"HaveGoal\" , variable_name = \"target_pose\" ) clr_goal1 = py_trees . blackboard . ClearBlackboardVariable ( name = \"ClearGoal\" , variable_name = \"target_pose\" ) clr_goal2 = py_trees . blackboard . ClearBlackboardVariable ( name = \"ClearGoal\" , variable_name = \"target_pose\" ) get_path = GetPath ( name = \"GetPath\" , action_namespace = \"/move_base_flex/get_path\" , action_spec = mbf_msgs . GetPathAction ) exe_path = ExePath ( name = \"ExePath\" , action_namespace = \"/move_base_flex/exe_path\" , action_spec = mbf_msgs . ExePathAction ) recovery = Recovery ( name = \"Recovery\" , action_namespace = \"/move_base_flex/recovery\" , action_spec = mbf_msgs . RecoveryAction ) # Compose tree bt_root . add_children ([ get_goal , fallback ]) get_goal . add_children ([ have_goal , new_goal ]) navigate . add_children ([ get_path , exe_path , clr_goal1 ]) fallback . add_children ([ navigate , recovery , clr_goal2 ]) return bt_root def shutdown ( behaviour_tree ): behaviour_tree . interrupt () if __name__ == '__main__' : rospy . init_node ( \"mbf_bt_demo\" ) root = create_root () behaviour_tree = py_trees_ros . trees . BehaviourTree ( root ) rospy . on_shutdown ( functools . partial ( shutdown , behaviour_tree )) if not behaviour_tree . setup ( timeout = 15 ): console . logerror ( \"failed to setup the tree, aborting.\" ) sys . exit ( 1 ) behaviour_tree . tick_tock ( 500 ) The Code Explained Behaviors Our tree requires five action behaviors: NewGoal , ClearGoal , GetPath , ExePath and Recovery and one check behavior: HaveGoal . NewGoal Move Base Flex expects a geometry_msgs/PoseStamped on topic /move_base_simple/goal . This goal can come from Rviz or can be published to topic directly. To create a NewGoal action behavior, add the following lines to your code: new_goal = py_trees_ros . subscribers . ToBlackboard ( name = \"NewGoal\" , topic_name = \"/move_base_simple/goal\" , topic_type = geometry_msgs . PoseStamped , blackboard_variables = { 'target_pose' : None }) GetPath The following lines declare the class GetPath extending ActionClient and create an action behavior we can later add to the tree. Ensure that you declare the correct namespace for the action (or remap appropriately with the launch file). In this simple demo we need to add very little additional code to the base ActionClient class, just gather data from the blackboard that is required to create the goal and add the result back to the blackboard, so other actions can use it. class GetPath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): \"\"\" Get target pose from the blackboard to create an action goal \"\"\" self . action_goal = mbf_msgs . GetPathGoal ( target_pose = py_trees . blackboard . Blackboard () . get ( \"target_pose\" )) super ( GetPath , self ) . initialise () def update ( self ): \"\"\" On success, set the resulting path on the blackboard, so ExePath can use it \"\"\" status = super ( GetPath , self ) . update () if status == py_trees . Status . SUCCESS : py_trees . blackboard . Blackboard () . set ( \"path\" , self . action_client . get_result () . path ) return status get_path = GetPath ( name = \"GetPath\" , action_namespace = \"/move_base_flex/get_path\" , action_spec = mbf_msgs . GetPathAction ) ExePath ExePath is very similar to GetPath class ExePath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): \"\"\" Get path from the blackboard to create an action goal \"\"\" self . action_goal = mbf_msgs . ExePathGoal ( path = py_trees . blackboard . Blackboard () . get ( \"path\" )) super ( ExePath , self ) . initialise () exe_path = ExePath ( name = \"ExePath\" , action_namespace = \"/move_base_flex/exe_path\" , action_spec = mbf_msgs . ExePathAction ) Be sure to set the correct namespace. We only use the goal path, not the result. Recovery The Recovery action is slightly more complicated because we need to manage the list of available recovery behaviors after retrieving them from ROS parameters server. Every time the action is executed, we try the next recovery behavior, dropping it from the list. Once exhausted, we fail to abort navigation, but also restore the list for the next goal. class Recovery ( py_trees_ros . actions . ActionClient ): def setup ( self , timeout ): \"\"\" Read the list of available recovery behaviors so we can try them in sequence \"\"\" self . _behaviors = rospy . get_param ( \"/move_base_flex/recovery_behaviors\" ) return super ( Recovery , self ) . setup ( timeout ) def update ( self ): \"\"\" Try the next recovery behavior, dropping it from the list \"\"\" try : self . action_goal = mbf_msgs . RecoveryGoal ( behavior = self . _behaviors . pop ( 0 )[ \"name\" ]) return super ( Recovery , self ) . update () except IndexError : # recovery behaviors exhausted; fail to abort navigation but restore the list for the next goal # TODO: this means that we won't reset the list after a successful recovery, so the list keeps shrinking # until fully exhausted; that's clearly not the expected operation, so I need to find a better solution self . _behaviors = rospy . get_param ( \"/move_base_flex/recovery_behaviors\" ) return py_trees . Status . FAILURE recovery = Recovery ( name = \"Recovery\" , action_namespace = \"/move_base_flex/recovery\" , action_spec = mbf_msgs . RecoveryAction ) Others The remaining action and check behaviors are much simpler and require a single line of code each. HaveGoal simple checks if \"target_pose\" variable is on the blackboard, while ClearGoal (used twice) removes the same variable from the blackboard: have_goal = py_trees.blackboard.CheckBlackboardVariable(name=\"HaveGoal\", variable_name=\"target_pose\") clr_goal1 = py_trees.blackboard.ClearBlackboardVariable(name=\"ClearGoal\", variable_name=\"target_pose\") clr_goal2 = py_trees.blackboard.ClearBlackboardVariable(name=\"ClearGoal\", variable_name=\"target_pose\") Composites For the simple behavior implemented here we need just four composites, two sequences and two selectors: bt_root = py_trees . composites . Sequence ( \"MBF BT Demo\" ) get_goal = py_trees . composites . Selector ( \"GetGoal\" ) fallback = py_trees . composites . Selector ( \"Fallback\" ) navigate = py_trees . composites . Sequence ( \"Navigate\" ) Composing the Tree bt_root . add_children ([ get_goal , fallback ]) get_goal . add_children ([ have_goal , new_goal ]) navigate . add_children ([ get_path , exe_path , clr_goal1 ]) fallback . add_children ([ navigate , recovery , clr_goal2 ]) GUI To display the BT with an rqt viewer, run: rosrun rqt_py_trees rqt_py_trees This a very useful tool to verify that your code actually composes the tree you have designed. Additionally, the viewer will help you to debug, as nodes are highlighted with a color scheme to show the current execution state: GREEN for SUCCESS RED for FAILURE BLUE for RUNNING GREY for unvisited. The GUI also provides: Tooltips : hover over a behavior to catch name, type, status and feedback message information Timeline : rewind as you wish, note the bars indicating where important events occurred","title":"Behavior Tree (Python)"},{"location":"tutorials/advanced/pytrees/#pytrees-move-base-flex-tutorial-python","text":"py_trees_ros is a Python-based behavior tree implementation and may be easier for you to use, depending on your background. If you are looking for C++ based Behavior Trees, try the previous tutorial","title":"PyTrees Move Base Flex Tutorial (Python)"},{"location":"tutorials/advanced/pytrees/#what-you-will-learn","text":"In this tutorial we address the actions GetPath , ExePath and Recovery provided by Move Base Flex. While GetPath runs the global planner searching for a path to the target pose, ExePath runs the local planner executing the planned path. The Recovery action can be used to execute various behaviors for error handling during planning and controlling. We connect these actions by setting up a py_trees_ros Behavior Tree (BT from now on) using ActionClient Behaviors. In addition to the actions described above, the implementation of a state that receives a navigation goal by the user is required. The target pose can be easily set via the visualization tool RViz and published on a specific topic. This tutorial very closely follows the ROS Wiki .","title":"What you will learn"},{"location":"tutorials/advanced/pytrees/#pytrees","text":"To learn about BTs and the particular library used here I encourage you to read py-trees documentation , and follow py_trees_ros tutorials to learn how to control ROS-based robots with BTs. As a minimum requirement to understand what's coming next, be sure you understand the following concepts: action behavior check behavior composite blackboard","title":"PyTrees"},{"location":"tutorials/advanced/pytrees/#the-code","text":"\"\"\" MBF BT Demo: Behavior tree implementing a really basic navigation strategy, even simpler than the move_base hardcoded FSM, as it lacks: * continuous replanning * oscillation detection We create on the first place action client behaviors for MBF's planner, controller and recovery action servers On this simple demo we need to add pretty little additional code to the base ActionClient class \"\"\" ############################################################################## # Imports ############################################################################## import functools import py_trees import py_trees_ros import py_trees.console as console import rospy import sys import geometry_msgs.msg as geometry_msgs import mbf_msgs.msg as mbf_msgs ############################################################################## # Actions ############################################################################## class GetPath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): \"\"\" Get target pose from the blackboard to create an action goal \"\"\" self . action_goal = mbf_msgs . GetPathGoal ( target_pose = py_trees . blackboard . Blackboard () . get ( \"target_pose\" )) super ( GetPath , self ) . initialise () def update ( self ): \"\"\" On success, set the resulting path on the blackboard, so ExePath can use it \"\"\" status = super ( GetPath , self ) . update () if status == py_trees . Status . SUCCESS : py_trees . blackboard . Blackboard () . set ( \"path\" , self . action_client . get_result () . path ) return status class ExePath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): \"\"\" Get path from the blackboard to create an action goal \"\"\" self . action_goal = mbf_msgs . ExePathGoal ( path = py_trees . blackboard . Blackboard () . get ( \"path\" )) super ( ExePath , self ) . initialise () class Recovery ( py_trees_ros . actions . ActionClient ): def setup ( self , timeout ): \"\"\" Read the list of available recovery behaviors so we can try them in sequence \"\"\" self . _behaviors = rospy . get_param ( \"/move_base_flex/recovery_behaviors\" ) return super ( Recovery , self ) . setup ( timeout ) def update ( self ): \"\"\" Try the next recovery behavior, dropping it from the list \"\"\" try : self . action_goal = mbf_msgs . RecoveryGoal ( behavior = self . _behaviors . pop ( 0 )[ \"name\" ]) return super ( Recovery , self ) . update () except IndexError : # recovery behaviors exhausted; fail to abort navigation but restore the list for the next goal # TODO: this means that we won't reset the list after a successful recovery, so the list keeps shrinking # until fully exhausted; that's clearly not the expected operation, so I need to find a better solution self . _behaviors = rospy . get_param ( \"/move_base_flex/recovery_behaviors\" ) return py_trees . Status . FAILURE ############################################################################## # Behaviours ############################################################################## def create_root (): # Create all behaviours bt_root = py_trees . composites . Sequence ( \"MBF BT Demo\" ) get_goal = py_trees . composites . Selector ( \"GetGoal\" ) fallback = py_trees . composites . Selector ( \"Fallback\" ) navigate = py_trees . composites . Sequence ( \"Navigate\" ) new_goal = py_trees_ros . subscribers . ToBlackboard ( name = \"NewGoal\" , topic_name = \"/move_base_simple/goal\" , topic_type = geometry_msgs . PoseStamped , blackboard_variables = { 'target_pose' : None }) have_goal = py_trees . blackboard . CheckBlackboardVariable ( name = \"HaveGoal\" , variable_name = \"target_pose\" ) clr_goal1 = py_trees . blackboard . ClearBlackboardVariable ( name = \"ClearGoal\" , variable_name = \"target_pose\" ) clr_goal2 = py_trees . blackboard . ClearBlackboardVariable ( name = \"ClearGoal\" , variable_name = \"target_pose\" ) get_path = GetPath ( name = \"GetPath\" , action_namespace = \"/move_base_flex/get_path\" , action_spec = mbf_msgs . GetPathAction ) exe_path = ExePath ( name = \"ExePath\" , action_namespace = \"/move_base_flex/exe_path\" , action_spec = mbf_msgs . ExePathAction ) recovery = Recovery ( name = \"Recovery\" , action_namespace = \"/move_base_flex/recovery\" , action_spec = mbf_msgs . RecoveryAction ) # Compose tree bt_root . add_children ([ get_goal , fallback ]) get_goal . add_children ([ have_goal , new_goal ]) navigate . add_children ([ get_path , exe_path , clr_goal1 ]) fallback . add_children ([ navigate , recovery , clr_goal2 ]) return bt_root def shutdown ( behaviour_tree ): behaviour_tree . interrupt () if __name__ == '__main__' : rospy . init_node ( \"mbf_bt_demo\" ) root = create_root () behaviour_tree = py_trees_ros . trees . BehaviourTree ( root ) rospy . on_shutdown ( functools . partial ( shutdown , behaviour_tree )) if not behaviour_tree . setup ( timeout = 15 ): console . logerror ( \"failed to setup the tree, aborting.\" ) sys . exit ( 1 ) behaviour_tree . tick_tock ( 500 )","title":"The Code"},{"location":"tutorials/advanced/pytrees/#the-code-explained","text":"","title":"The Code Explained"},{"location":"tutorials/advanced/pytrees/#behaviors","text":"Our tree requires five action behaviors: NewGoal , ClearGoal , GetPath , ExePath and Recovery and one check behavior: HaveGoal .","title":"Behaviors"},{"location":"tutorials/advanced/pytrees/#newgoal","text":"Move Base Flex expects a geometry_msgs/PoseStamped on topic /move_base_simple/goal . This goal can come from Rviz or can be published to topic directly. To create a NewGoal action behavior, add the following lines to your code: new_goal = py_trees_ros . subscribers . ToBlackboard ( name = \"NewGoal\" , topic_name = \"/move_base_simple/goal\" , topic_type = geometry_msgs . PoseStamped , blackboard_variables = { 'target_pose' : None })","title":"NewGoal"},{"location":"tutorials/advanced/pytrees/#getpath","text":"The following lines declare the class GetPath extending ActionClient and create an action behavior we can later add to the tree. Ensure that you declare the correct namespace for the action (or remap appropriately with the launch file). In this simple demo we need to add very little additional code to the base ActionClient class, just gather data from the blackboard that is required to create the goal and add the result back to the blackboard, so other actions can use it. class GetPath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): \"\"\" Get target pose from the blackboard to create an action goal \"\"\" self . action_goal = mbf_msgs . GetPathGoal ( target_pose = py_trees . blackboard . Blackboard () . get ( \"target_pose\" )) super ( GetPath , self ) . initialise () def update ( self ): \"\"\" On success, set the resulting path on the blackboard, so ExePath can use it \"\"\" status = super ( GetPath , self ) . update () if status == py_trees . Status . SUCCESS : py_trees . blackboard . Blackboard () . set ( \"path\" , self . action_client . get_result () . path ) return status get_path = GetPath ( name = \"GetPath\" , action_namespace = \"/move_base_flex/get_path\" , action_spec = mbf_msgs . GetPathAction )","title":"GetPath"},{"location":"tutorials/advanced/pytrees/#exepath","text":"ExePath is very similar to GetPath class ExePath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): \"\"\" Get path from the blackboard to create an action goal \"\"\" self . action_goal = mbf_msgs . ExePathGoal ( path = py_trees . blackboard . Blackboard () . get ( \"path\" )) super ( ExePath , self ) . initialise () exe_path = ExePath ( name = \"ExePath\" , action_namespace = \"/move_base_flex/exe_path\" , action_spec = mbf_msgs . ExePathAction ) Be sure to set the correct namespace. We only use the goal path, not the result.","title":"ExePath"},{"location":"tutorials/advanced/pytrees/#recovery","text":"The Recovery action is slightly more complicated because we need to manage the list of available recovery behaviors after retrieving them from ROS parameters server. Every time the action is executed, we try the next recovery behavior, dropping it from the list. Once exhausted, we fail to abort navigation, but also restore the list for the next goal. class Recovery ( py_trees_ros . actions . ActionClient ): def setup ( self , timeout ): \"\"\" Read the list of available recovery behaviors so we can try them in sequence \"\"\" self . _behaviors = rospy . get_param ( \"/move_base_flex/recovery_behaviors\" ) return super ( Recovery , self ) . setup ( timeout ) def update ( self ): \"\"\" Try the next recovery behavior, dropping it from the list \"\"\" try : self . action_goal = mbf_msgs . RecoveryGoal ( behavior = self . _behaviors . pop ( 0 )[ \"name\" ]) return super ( Recovery , self ) . update () except IndexError : # recovery behaviors exhausted; fail to abort navigation but restore the list for the next goal # TODO: this means that we won't reset the list after a successful recovery, so the list keeps shrinking # until fully exhausted; that's clearly not the expected operation, so I need to find a better solution self . _behaviors = rospy . get_param ( \"/move_base_flex/recovery_behaviors\" ) return py_trees . Status . FAILURE recovery = Recovery ( name = \"Recovery\" , action_namespace = \"/move_base_flex/recovery\" , action_spec = mbf_msgs . RecoveryAction )","title":"Recovery"},{"location":"tutorials/advanced/pytrees/#others","text":"The remaining action and check behaviors are much simpler and require a single line of code each. HaveGoal simple checks if \"target_pose\" variable is on the blackboard, while ClearGoal (used twice) removes the same variable from the blackboard: have_goal = py_trees.blackboard.CheckBlackboardVariable(name=\"HaveGoal\", variable_name=\"target_pose\") clr_goal1 = py_trees.blackboard.ClearBlackboardVariable(name=\"ClearGoal\", variable_name=\"target_pose\") clr_goal2 = py_trees.blackboard.ClearBlackboardVariable(name=\"ClearGoal\", variable_name=\"target_pose\")","title":"Others"},{"location":"tutorials/advanced/pytrees/#composites","text":"For the simple behavior implemented here we need just four composites, two sequences and two selectors: bt_root = py_trees . composites . Sequence ( \"MBF BT Demo\" ) get_goal = py_trees . composites . Selector ( \"GetGoal\" ) fallback = py_trees . composites . Selector ( \"Fallback\" ) navigate = py_trees . composites . Sequence ( \"Navigate\" )","title":"Composites"},{"location":"tutorials/advanced/pytrees/#composing-the-tree","text":"bt_root . add_children ([ get_goal , fallback ]) get_goal . add_children ([ have_goal , new_goal ]) navigate . add_children ([ get_path , exe_path , clr_goal1 ]) fallback . add_children ([ navigate , recovery , clr_goal2 ])","title":"Composing the Tree"},{"location":"tutorials/advanced/pytrees/#gui","text":"To display the BT with an rqt viewer, run: rosrun rqt_py_trees rqt_py_trees This a very useful tool to verify that your code actually composes the tree you have designed. Additionally, the viewer will help you to debug, as nodes are highlighted with a color scheme to show the current execution state: GREEN for SUCCESS RED for FAILURE BLUE for RUNNING GREY for unvisited. The GUI also provides: Tooltips : hover over a behavior to catch name, type, status and feedback message information Timeline : rewind as you wish, note the bars indicating where important events occurred","title":"GUI"},{"location":"tutorials/advanced/recovery_behavior/","text":"Recovery Behavior WIP: noetic release of moveback_recovery . Recovering from unknown or failure conditions in dynamic planning environment can be implemented with revovery behaviors. Recovery behavior is usually implemented to only trigger when continuous replanning has failed. They can be loaded into Move Base Flex the same way controllers and planners are configured: recovery_behaviors: - name: rotate_recovery type: rotate_recovery/RotateRecovery - name: clear_costmap_recovery type: clear_costmap_recovery/ClearCostmapRecovery recovery_enabled: true recovery_patience: 15.0 This means that the robot will first try to rotate itself and replan. If this fails however, the costmap will be cleared. This may be necessary if there are sensor issues. Recovery behavior is enabled by default, but the specific plugins have to be implemented/loaded by the user. Many other recovery plugins are available for your ROS distro, which are not explicitely covered here. Run the example Note Replanning is turned of in this scenario to produce fatal conditions for the robot with less effort. This shouldn't be done in a production system! Launch the gazebo world for turtlebot: export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch Launch Move Base Flex in recovery mode: export TURTLEBOT3_MODEL = burger roslaunch mbf_advanced amcl_demo_mbf_recovery.launch Launch a goal publising node, e.g. the example from the beginner tutorial roslaunch mbf_beginner mbf_goal_client.py Now grab the blue box in Gazebo, and drop it somewhere in front of the robot. You will see that the robot will attempt to rotate itself, and if that fails, clears the costmap temporarily!","title":"Recovery Behavior"},{"location":"tutorials/advanced/recovery_behavior/#recovery-behavior","text":"WIP: noetic release of moveback_recovery . Recovering from unknown or failure conditions in dynamic planning environment can be implemented with revovery behaviors. Recovery behavior is usually implemented to only trigger when continuous replanning has failed. They can be loaded into Move Base Flex the same way controllers and planners are configured: recovery_behaviors: - name: rotate_recovery type: rotate_recovery/RotateRecovery - name: clear_costmap_recovery type: clear_costmap_recovery/ClearCostmapRecovery recovery_enabled: true recovery_patience: 15.0 This means that the robot will first try to rotate itself and replan. If this fails however, the costmap will be cleared. This may be necessary if there are sensor issues. Recovery behavior is enabled by default, but the specific plugins have to be implemented/loaded by the user. Many other recovery plugins are available for your ROS distro, which are not explicitely covered here.","title":"Recovery Behavior"},{"location":"tutorials/advanced/recovery_behavior/#run-the-example","text":"Note Replanning is turned of in this scenario to produce fatal conditions for the robot with less effort. This shouldn't be done in a production system! Launch the gazebo world for turtlebot: export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch Launch Move Base Flex in recovery mode: export TURTLEBOT3_MODEL = burger roslaunch mbf_advanced amcl_demo_mbf_recovery.launch Launch a goal publising node, e.g. the example from the beginner tutorial roslaunch mbf_beginner mbf_goal_client.py Now grab the blue box in Gazebo, and drop it somewhere in front of the robot. You will see that the robot will attempt to rotate itself, and if that fails, clears the costmap temporarily!","title":"Run the example"},{"location":"tutorials/advanced/smach/","text":"Writing a SMACH This Tutorial will walk you through writing a simple SMACH. SMACH stands for S tate Mach ine and is an important concept in the ROS Navigation ecosystem. You can check out the official ROS SMACH Tutorials , as well. The following SMACH tutorial will perform the circular path you already know from previous tutorials by using path planning with the /mbf_msgs/GetPath.action and execution from within a simple SMACH with /mbf_msgs/ExePath.action . Code import rospy import smach import smach_ros import threading from geometry_msgs.msg import PoseStamped from nav_msgs.msg import Path from mbf_msgs.msg import ExePathAction from mbf_msgs.msg import GetPathAction from mbf_msgs.msg import RecoveryAction def create_pose ( x , y , z , xx , yy , zz , ww ): pose = PoseStamped () pose . header . frame_id = \"map\" pose . header . stamp = rospy . Time . now () pose . pose . position . x = x pose . pose . position . y = y pose . pose . position . z = z pose . pose . orientation . x = xx pose . pose . orientation . y = yy pose . pose . orientation . z = zz pose . pose . orientation . w = ww return pose def iterate_target_poses (): target_poses = [ create_pose ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_pose ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), create_pose ( 0.957 , 1.60 , 0 , 0 , 0 , - 0.163 , 0.987 ), create_pose ( 1.8741 , 0.3830 , 0 , 0 , 0 , - 0.70 , 0.711 ), create_pose ( 1.752 , - 0.928 , 0 , 0 , 0 , - 0.856 , 0.517 ), create_pose ( 0.418 , - 2.116 , 0 , 0 , 0 , 0.998 , 0.0619 ), create_pose ( - 0.775 , - 1.80 , 0 , 0 , 0 , 0.954 , 0.300 ), create_pose ( - 1.990 , - 0.508 , 0 , 0 , 0 , - 0.112 , 0.999 ) ] for target_pose in target_poses : yield target_pose def create_path_goal ( path , tolerance_from_action , dist_tolerance , angle_tolerance ): goal = mbf_msgs . ExePathGoal () goal . path = path goal . tolerance_from_action = tolerance_from_action goal . dist_tolerance = dist_tolerance goal . angle_tolerance = angle_tolerance return goal def main (): rospy . init_node ( 'mbf_state_machine' ) target_poses = iterate_target_poses () # Create SMACH state machine sm = smach . StateMachine ( outcomes = [ 'succeeded' , 'aborted' , 'preempted' ]) # Define userdata sm . userdata . target_pose = None sm . userdata . path = None sm . userdata . error = None sm . userdata . clear_costmap_flag = False sm . userdata . error_status = None with sm : # path callback def get_path_callback ( userdata , goal ): try : goal . target_pose = next ( target_poses ) except StopIteration : rospy . logwarn ( \"Reached last target pose\" ) rospy . signal_shutdown ( \"Last goal reached. Shutting down\" ) # Get path smach . StateMachine . add ( 'GET_PATH' , smach_ros . SimpleActionState ( '/move_base_flex/get_path' , GetPathAction , goal_cb = get_path_callback , goal_slots = [ 'target_pose' ], result_slots = [ 'path' ] ), transitions = { 'succeeded' : 'EXE_PATH' , 'aborted' : 'aborted' , 'preempted' : 'preempted' } ) def path_callback ( userdata , goal ): target_pose = goal . path . poses [ - 1 ] . pose rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , target_pose . position . x , target_pose . position . y ) # Execute path smach . StateMachine . add ( 'EXE_PATH' , smach_ros . SimpleActionState ( '/move_base_flex/exe_path' , ExePathAction , goal_cb = path_callback , goal_slots = [ 'path' ] ), transitions = { 'succeeded' : 'GET_PATH' , 'aborted' : 'aborted' , 'preempted' : 'preempted' } ) # Execute SMACH plan # Create a thread to execute the smach container smach_thread = threading . Thread ( target = sm . execute ) smach_thread . start () # Wait for ctrl-c rospy . spin () # Request the container to preempt sm . request_preempt () # Block until everything is preempted smach_thread . join () if __name__ == \"__main__\" : main () The Code Explained Let's define the State Machine with three outcomes: succeeded , aborted and preempted : # Create SMACH state machine sm = smach . StateMachine ( outcomes = [ 'succeeded' , 'aborted' , 'preempted' ]) Next, we need to add states to the SMACH. In this simple case, all we need is a state to handle path planning, GET_PATH and another to handle the path execution, EXE_PATH . The states use smach_ros The smach_ros package contains extensions for the SMACH library to integrate it tightly with ROS. For example, SMACH-ROS can call ROS services, listen to ROS topics, and integrate with actionlib both as a client, and a provider of action servers. SMACH is a new library that takes advantage of very old concepts in order to quickly create robust robot behavior with maintainable and modular code. GET_PATH State smach . StateMachine . add ( 'GET_PATH' , smach_ros . SimpleActionState ( '/move_base_flex/get_path' , GetPathAction , goal_cb = get_path_callback , goal_slots = [ 'target_pose' ], result_slots = [ 'path' ] ), transitions = { 'succeeded' : 'EXE_PATH' , 'aborted' : 'aborted' , 'preempted' : 'preempted' }, remapping = { 'target_pose' : 'goal' } ) In our case, we need access to the goal, to tell out robot about the next waypoint: goal_slots=['target_pose'] the path, to tell the next state which path to execute: result_slots=['path'] While the goal_slots define the input values, result_slots indicate the output values. The seconds parameter tells the SMACH which action server to use to receive a path: /move_base_flex/get_path with the mbf_msgs/GetPathAction we already know from the beginner tutorials. The transitions parameters configures which states are visited next, depending on the result of the state. Note : If goals/results and userdata are named differently, you can change them with the remapping argument (not necessary in our case). e.g.: remapping = { 'target_pose' : 'goal' } Next use this callback to set the goal. After we set the goal, the state calls the /move_base_flex/get_path action server, and relays the result to the next state (Shown shortly). def get_path_callback ( userdata , goal ): try : goal . target_pose = next ( target_poses ) except StopIteration : rospy . logwarn ( \"Reached last target pose\" ) rospy . signal_shutdown ( \"Last goal reached. Shutting down\" ) EXE_PATH State smach . StateMachine . add ( 'EXE_PATH' , smach_ros . SimpleActionState ( '/move_base_flex/exe_path' , ExePathAction , goal_cb = path_callback , goal_slots = [ 'path' ] ), transitions = { 'succeeded' : 'GET_PATH' , 'aborted' : 'aborted' , 'preempted' : 'preempted' } ) the EXE_PATH state receives a path via userdata an is declared with goal_slots=['path'] . On success, the path will transition to the GET_PATH state and will try to plan a new path from there. The exe_path_callback is used for verbosity only def exe_path_callback ( userdata , goal ): target_pose = goal . path . poses [ - 1 ] . pose rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , target_pose . position . x , target_pose . position . y ) Userdata Finally, the result and goal slots we used to determine how the data will be passed between states, need to be set in the userdata : # Define userdata sm . userdata . goal = None sm . userdata . path = None Run the SMACH Launch gazebo export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch as well as Move Base Flex export TURTLEBOT3_MODEL = burger roslaunch mbf_advanced amcl_demo_mbf.launch Finally, start the SMACH rosrun mbf_advanced circle_smach.py","title":"Writing a simple SMACH"},{"location":"tutorials/advanced/smach/#writing-a-smach","text":"This Tutorial will walk you through writing a simple SMACH. SMACH stands for S tate Mach ine and is an important concept in the ROS Navigation ecosystem. You can check out the official ROS SMACH Tutorials , as well. The following SMACH tutorial will perform the circular path you already know from previous tutorials by using path planning with the /mbf_msgs/GetPath.action and execution from within a simple SMACH with /mbf_msgs/ExePath.action .","title":"Writing a SMACH"},{"location":"tutorials/advanced/smach/#code","text":"import rospy import smach import smach_ros import threading from geometry_msgs.msg import PoseStamped from nav_msgs.msg import Path from mbf_msgs.msg import ExePathAction from mbf_msgs.msg import GetPathAction from mbf_msgs.msg import RecoveryAction def create_pose ( x , y , z , xx , yy , zz , ww ): pose = PoseStamped () pose . header . frame_id = \"map\" pose . header . stamp = rospy . Time . now () pose . pose . position . x = x pose . pose . position . y = y pose . pose . position . z = z pose . pose . orientation . x = xx pose . pose . orientation . y = yy pose . pose . orientation . z = zz pose . pose . orientation . w = ww return pose def iterate_target_poses (): target_poses = [ create_pose ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_pose ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), create_pose ( 0.957 , 1.60 , 0 , 0 , 0 , - 0.163 , 0.987 ), create_pose ( 1.8741 , 0.3830 , 0 , 0 , 0 , - 0.70 , 0.711 ), create_pose ( 1.752 , - 0.928 , 0 , 0 , 0 , - 0.856 , 0.517 ), create_pose ( 0.418 , - 2.116 , 0 , 0 , 0 , 0.998 , 0.0619 ), create_pose ( - 0.775 , - 1.80 , 0 , 0 , 0 , 0.954 , 0.300 ), create_pose ( - 1.990 , - 0.508 , 0 , 0 , 0 , - 0.112 , 0.999 ) ] for target_pose in target_poses : yield target_pose def create_path_goal ( path , tolerance_from_action , dist_tolerance , angle_tolerance ): goal = mbf_msgs . ExePathGoal () goal . path = path goal . tolerance_from_action = tolerance_from_action goal . dist_tolerance = dist_tolerance goal . angle_tolerance = angle_tolerance return goal def main (): rospy . init_node ( 'mbf_state_machine' ) target_poses = iterate_target_poses () # Create SMACH state machine sm = smach . StateMachine ( outcomes = [ 'succeeded' , 'aborted' , 'preempted' ]) # Define userdata sm . userdata . target_pose = None sm . userdata . path = None sm . userdata . error = None sm . userdata . clear_costmap_flag = False sm . userdata . error_status = None with sm : # path callback def get_path_callback ( userdata , goal ): try : goal . target_pose = next ( target_poses ) except StopIteration : rospy . logwarn ( \"Reached last target pose\" ) rospy . signal_shutdown ( \"Last goal reached. Shutting down\" ) # Get path smach . StateMachine . add ( 'GET_PATH' , smach_ros . SimpleActionState ( '/move_base_flex/get_path' , GetPathAction , goal_cb = get_path_callback , goal_slots = [ 'target_pose' ], result_slots = [ 'path' ] ), transitions = { 'succeeded' : 'EXE_PATH' , 'aborted' : 'aborted' , 'preempted' : 'preempted' } ) def path_callback ( userdata , goal ): target_pose = goal . path . poses [ - 1 ] . pose rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , target_pose . position . x , target_pose . position . y ) # Execute path smach . StateMachine . add ( 'EXE_PATH' , smach_ros . SimpleActionState ( '/move_base_flex/exe_path' , ExePathAction , goal_cb = path_callback , goal_slots = [ 'path' ] ), transitions = { 'succeeded' : 'GET_PATH' , 'aborted' : 'aborted' , 'preempted' : 'preempted' } ) # Execute SMACH plan # Create a thread to execute the smach container smach_thread = threading . Thread ( target = sm . execute ) smach_thread . start () # Wait for ctrl-c rospy . spin () # Request the container to preempt sm . request_preempt () # Block until everything is preempted smach_thread . join () if __name__ == \"__main__\" : main ()","title":"Code"},{"location":"tutorials/advanced/smach/#the-code-explained","text":"Let's define the State Machine with three outcomes: succeeded , aborted and preempted : # Create SMACH state machine sm = smach . StateMachine ( outcomes = [ 'succeeded' , 'aborted' , 'preempted' ]) Next, we need to add states to the SMACH. In this simple case, all we need is a state to handle path planning, GET_PATH and another to handle the path execution, EXE_PATH . The states use smach_ros The smach_ros package contains extensions for the SMACH library to integrate it tightly with ROS. For example, SMACH-ROS can call ROS services, listen to ROS topics, and integrate with actionlib both as a client, and a provider of action servers. SMACH is a new library that takes advantage of very old concepts in order to quickly create robust robot behavior with maintainable and modular code.","title":"The Code Explained"},{"location":"tutorials/advanced/smach/#get_path-state","text":"smach . StateMachine . add ( 'GET_PATH' , smach_ros . SimpleActionState ( '/move_base_flex/get_path' , GetPathAction , goal_cb = get_path_callback , goal_slots = [ 'target_pose' ], result_slots = [ 'path' ] ), transitions = { 'succeeded' : 'EXE_PATH' , 'aborted' : 'aborted' , 'preempted' : 'preempted' }, remapping = { 'target_pose' : 'goal' } ) In our case, we need access to the goal, to tell out robot about the next waypoint: goal_slots=['target_pose'] the path, to tell the next state which path to execute: result_slots=['path'] While the goal_slots define the input values, result_slots indicate the output values. The seconds parameter tells the SMACH which action server to use to receive a path: /move_base_flex/get_path with the mbf_msgs/GetPathAction we already know from the beginner tutorials. The transitions parameters configures which states are visited next, depending on the result of the state. Note : If goals/results and userdata are named differently, you can change them with the remapping argument (not necessary in our case). e.g.: remapping = { 'target_pose' : 'goal' } Next use this callback to set the goal. After we set the goal, the state calls the /move_base_flex/get_path action server, and relays the result to the next state (Shown shortly). def get_path_callback ( userdata , goal ): try : goal . target_pose = next ( target_poses ) except StopIteration : rospy . logwarn ( \"Reached last target pose\" ) rospy . signal_shutdown ( \"Last goal reached. Shutting down\" )","title":"GET_PATH State"},{"location":"tutorials/advanced/smach/#exe_path-state","text":"smach . StateMachine . add ( 'EXE_PATH' , smach_ros . SimpleActionState ( '/move_base_flex/exe_path' , ExePathAction , goal_cb = path_callback , goal_slots = [ 'path' ] ), transitions = { 'succeeded' : 'GET_PATH' , 'aborted' : 'aborted' , 'preempted' : 'preempted' } ) the EXE_PATH state receives a path via userdata an is declared with goal_slots=['path'] . On success, the path will transition to the GET_PATH state and will try to plan a new path from there. The exe_path_callback is used for verbosity only def exe_path_callback ( userdata , goal ): target_pose = goal . path . poses [ - 1 ] . pose rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , target_pose . position . x , target_pose . position . y )","title":"EXE_PATH State"},{"location":"tutorials/advanced/smach/#userdata","text":"Finally, the result and goal slots we used to determine how the data will be passed between states, need to be set in the userdata : # Define userdata sm . userdata . goal = None sm . userdata . path = None","title":"Userdata"},{"location":"tutorials/advanced/smach/#run-the-smach","text":"Launch gazebo export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch as well as Move Base Flex export TURTLEBOT3_MODEL = burger roslaunch mbf_advanced amcl_demo_mbf.launch Finally, start the SMACH rosrun mbf_advanced circle_smach.py","title":"Run the SMACH"},{"location":"tutorials/beginner/basic_navigation/","text":"Basic Navigation Run tutorial For a quick demo, just follow the following steps. You will learn how to control the turtlebot in a simulation environment, with the help of RViz. Because this is so simple (in principle), we will relay Move Base Messages to Move Base Flex and let Move Base Flex take over planning. Let's begin. Clone mbf_tutorials git clone git@github.com:uos/mbf_tutorials.git ~/catkin_ws/src/mbf_tutorials Install dependencies with rosdep (include all tutorials for ease of use) rosdep install mbf_beginner mbf_advanced Using ROS noetic? rosdep install will fail for eband_local_planner , because the team hasn't released the version for noetic yet. Simply clone the repository: git clone git@github.com:utexas-bwi/eband_local_planner.git ~/catkin_ws/src/eband_local_planner From source of workspace: cd ~/catkin_ws/src catkin_make -j4 && source devel/setup.bash ` Launch the appropriate gazebo world export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch Start localization (AMCL) export TURTLEBOT3_MODEL = burger roslaunch mbf_beginner amcl_demo_relay_subscriber.launch Launch Rviz roslaunch mbf_beginner rviz.launch In RViz Set an Initial Pose estimate with the 2D Pose Estimate Pose Finally set your Navigation Goal with the 2D Nav Goal Pose You will now be able to navigate in a similar fashion to this: What is happening here? We used Move Base Flex by relaying mb_msgs/MoveBaseAction to mbf_msgs/MoveBaseAction in a standard Move Base goal callback. This is useful in case you want to use Move Base Flex as a drop-in replacement for Move Base and want to take advantage of continous replanning, which is built into Move Base Flex, but not Move Base. Code import actionlib import rospy import nav_msgs.srv as nav_srvs import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs from geometry_msgs.msg import PoseStamped def simple_goal_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg )) rospy . logdebug ( \"Relaying move_base_simple/goal pose to mbf\" ) mbf_mb_ac . wait_for_result () status = mbf_mb_ac . get_state () result = mbf_mb_ac . get_result () rospy . logdebug ( \"MBF execution completed with result [ %d ]: %s \" , result . outcome , result . message ) if __name__ == '__main__' : rospy . init_node ( \"move_base_relay\" ) # move base flex ation client relays incoming mb goals to mbf mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 20 )) # move_base simple topic and action server mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) rospy . spin () The Code Explained MoveBase subscriber to handle goal events mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) MoveBase expects goal Messages ( geometry_msgs/Pose ) on topic move_base_simple/goal . The subscriber callback simple_goal_cb handles the mbf_msgs.MoveBaseAction ROS Action Client. The Move Base Flex SimpleActionServer is launched from within Move Base Flex. mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) ... def simple_goal_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg )) and relays the MoveBaseAction to the Move Base Flex action client! At this stage, we are using the global planner and local planner defined in move_base.yml . A Relay with more control While the first example allows you to relay messages to Move Base Flex, the only way to reach goals is by setting a 2D Navigation Goal via RViz, which can be limiting. This examples allows you to send goals directly from a ROS node. Code Server import actionlib import rospy import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs def mb_execute_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg . target_pose ), feedback_cb = mbf_feedback_cb ) rospy . logdebug ( \"Relaying move_base goal to mbf\" ) mbf_mb_ac . wait_for_result () status = mbf_mb_ac . get_state () result = mbf_mb_ac . get_result () rospy . logdebug ( \"MBF execution completed with result [ %d ]: %s \" , result . outcome , result . message ) if result . outcome == mbf_msgs . MoveBaseResult . SUCCESS : mb_as . set_succeeded ( mb_msgs . MoveBaseResult (), \"Goal reached.\" ) else : mb_as . set_aborted ( mb_msgs . MoveBaseResult (), result . message ) def mbf_feedback_cb ( feedback ): mb_as . publish_feedback ( mb_msgs . MoveBaseFeedback ( base_position = feedback . current_pose )) if __name__ == '__main__' : rospy . init_node ( \"move_base\" ) # move_base_flex get_path and move_base action clients mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 10 )) mb_as = actionlib . SimpleActionServer ( 'move_base' , mb_msgs . MoveBaseAction , mb_execute_cb , auto_start = False ) mb_as . start () rospy . spin () Client import rospy import actionlib import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs from actionlib_msgs.msg import GoalStatus def create_goal ( x , y , z , xx , yy , zz , ww ): goal = mb_msgs . MoveBaseGoal () ... goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z ... return goal def move ( goal ): client . send_goal ( goal ) client . wait_for_result () return client . get_state () == GoalStatus . SUCCEEDED def drive_circle (): goals = [ create_goal ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_goal ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), ... ] for goal in goals : rospy . loginfo ( \"Attempting to drive to %s %s \" , goal . target_pose . pose . position . x , goal . target_pose . pose . position . y ) if not move ( goal ): return False return True if __name__ == '__main__' : try : rospy . init_node ( 'mb_relay_client' ) client = actionlib . SimpleActionClient ( 'move_base' , mb_msgs . MoveBaseAction ) client . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to SimpleActionServer 'move_base'\" ) result = drive_circle () rospy . loginfo ( \"Drove circle with result: %s \" , result ) except rospy . ROSInterruptException : rospy . logerror ( \"program interrupted before completion\" ) The Code Explained On the server side, we start a standard Move Base Action Server, and connect a Move Base Flex Action Client to the default Move Base Flex Action Server. mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 10 )) mb_as = actionlib . SimpleActionServer ( 'move_base' , mb_msgs . MoveBaseAction , mb_execute_cb , auto_start = False ) We then relay the goal in the callback of the Move Base Action Server, like in the first subriber callback example def mb_execute_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg . target_pose ), feedback_cb = mbf_feedback_cb ) On the client side, we simply connect to the Move Base Action Server, and send a goal, which is then relayed in the above function. client = actionlib . SimpleActionClient ( 'move_base' , mb_msgs . MoveBaseAction ) client . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to SimpleActionServer 'move_base'\" ) In this example, the robot will follow a (rough) circular path around the turtlebot3_gazebo world. A goal is created like this: goal = mb_msgs . MoveBaseGoal () goal . target_pose . header . frame_id = \"map\" goal . target_pose . header . stamp = rospy . Time . now () goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z goal . target_pose . pose . orientation . x = xx goal . target_pose . pose . orientation . y = yy goal . target_pose . pose . orientation . z = zz goal . target_pose . pose . orientation . w = ww return goal and sent to the action server: client . send_goal ( goal ) client . wait_for_result () return client . get_state () == GoalStatus . SUCCEEDED Run the example Launch gazebo export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch as well as the server export TURTLEBOT3_MODEL = burger roslaunch mbf_beginner amcl_demo_relay_server.launch and client node to send the goals! rosrun mbf_beginner mb_relay_client.py The Result Open RViz with roslaunch mbf_beginner rviz.launch The full source code can be found here .","title":"Basic Navigation"},{"location":"tutorials/beginner/basic_navigation/#basic-navigation","text":"","title":"Basic Navigation"},{"location":"tutorials/beginner/basic_navigation/#run-tutorial","text":"For a quick demo, just follow the following steps. You will learn how to control the turtlebot in a simulation environment, with the help of RViz. Because this is so simple (in principle), we will relay Move Base Messages to Move Base Flex and let Move Base Flex take over planning. Let's begin. Clone mbf_tutorials git clone git@github.com:uos/mbf_tutorials.git ~/catkin_ws/src/mbf_tutorials Install dependencies with rosdep (include all tutorials for ease of use) rosdep install mbf_beginner mbf_advanced Using ROS noetic? rosdep install will fail for eband_local_planner , because the team hasn't released the version for noetic yet. Simply clone the repository: git clone git@github.com:utexas-bwi/eband_local_planner.git ~/catkin_ws/src/eband_local_planner From source of workspace: cd ~/catkin_ws/src catkin_make -j4 && source devel/setup.bash ` Launch the appropriate gazebo world export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch Start localization (AMCL) export TURTLEBOT3_MODEL = burger roslaunch mbf_beginner amcl_demo_relay_subscriber.launch Launch Rviz roslaunch mbf_beginner rviz.launch In RViz Set an Initial Pose estimate with the 2D Pose Estimate Pose Finally set your Navigation Goal with the 2D Nav Goal Pose You will now be able to navigate in a similar fashion to this:","title":"Run tutorial"},{"location":"tutorials/beginner/basic_navigation/#what-is-happening-here","text":"We used Move Base Flex by relaying mb_msgs/MoveBaseAction to mbf_msgs/MoveBaseAction in a standard Move Base goal callback. This is useful in case you want to use Move Base Flex as a drop-in replacement for Move Base and want to take advantage of continous replanning, which is built into Move Base Flex, but not Move Base.","title":"What is happening here?"},{"location":"tutorials/beginner/basic_navigation/#code","text":"import actionlib import rospy import nav_msgs.srv as nav_srvs import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs from geometry_msgs.msg import PoseStamped def simple_goal_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg )) rospy . logdebug ( \"Relaying move_base_simple/goal pose to mbf\" ) mbf_mb_ac . wait_for_result () status = mbf_mb_ac . get_state () result = mbf_mb_ac . get_result () rospy . logdebug ( \"MBF execution completed with result [ %d ]: %s \" , result . outcome , result . message ) if __name__ == '__main__' : rospy . init_node ( \"move_base_relay\" ) # move base flex ation client relays incoming mb goals to mbf mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 20 )) # move_base simple topic and action server mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) rospy . spin ()","title":"Code"},{"location":"tutorials/beginner/basic_navigation/#the-code-explained","text":"MoveBase subscriber to handle goal events mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) MoveBase expects goal Messages ( geometry_msgs/Pose ) on topic move_base_simple/goal . The subscriber callback simple_goal_cb handles the mbf_msgs.MoveBaseAction ROS Action Client. The Move Base Flex SimpleActionServer is launched from within Move Base Flex. mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) ... def simple_goal_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg )) and relays the MoveBaseAction to the Move Base Flex action client! At this stage, we are using the global planner and local planner defined in move_base.yml .","title":"The Code Explained"},{"location":"tutorials/beginner/basic_navigation/#a-relay-with-more-control","text":"While the first example allows you to relay messages to Move Base Flex, the only way to reach goals is by setting a 2D Navigation Goal via RViz, which can be limiting. This examples allows you to send goals directly from a ROS node.","title":"A Relay with more control"},{"location":"tutorials/beginner/basic_navigation/#code_1","text":"Server import actionlib import rospy import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs def mb_execute_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg . target_pose ), feedback_cb = mbf_feedback_cb ) rospy . logdebug ( \"Relaying move_base goal to mbf\" ) mbf_mb_ac . wait_for_result () status = mbf_mb_ac . get_state () result = mbf_mb_ac . get_result () rospy . logdebug ( \"MBF execution completed with result [ %d ]: %s \" , result . outcome , result . message ) if result . outcome == mbf_msgs . MoveBaseResult . SUCCESS : mb_as . set_succeeded ( mb_msgs . MoveBaseResult (), \"Goal reached.\" ) else : mb_as . set_aborted ( mb_msgs . MoveBaseResult (), result . message ) def mbf_feedback_cb ( feedback ): mb_as . publish_feedback ( mb_msgs . MoveBaseFeedback ( base_position = feedback . current_pose )) if __name__ == '__main__' : rospy . init_node ( \"move_base\" ) # move_base_flex get_path and move_base action clients mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 10 )) mb_as = actionlib . SimpleActionServer ( 'move_base' , mb_msgs . MoveBaseAction , mb_execute_cb , auto_start = False ) mb_as . start () rospy . spin () Client import rospy import actionlib import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs from actionlib_msgs.msg import GoalStatus def create_goal ( x , y , z , xx , yy , zz , ww ): goal = mb_msgs . MoveBaseGoal () ... goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z ... return goal def move ( goal ): client . send_goal ( goal ) client . wait_for_result () return client . get_state () == GoalStatus . SUCCEEDED def drive_circle (): goals = [ create_goal ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_goal ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), ... ] for goal in goals : rospy . loginfo ( \"Attempting to drive to %s %s \" , goal . target_pose . pose . position . x , goal . target_pose . pose . position . y ) if not move ( goal ): return False return True if __name__ == '__main__' : try : rospy . init_node ( 'mb_relay_client' ) client = actionlib . SimpleActionClient ( 'move_base' , mb_msgs . MoveBaseAction ) client . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to SimpleActionServer 'move_base'\" ) result = drive_circle () rospy . loginfo ( \"Drove circle with result: %s \" , result ) except rospy . ROSInterruptException : rospy . logerror ( \"program interrupted before completion\" )","title":"Code"},{"location":"tutorials/beginner/basic_navigation/#the-code-explained_1","text":"On the server side, we start a standard Move Base Action Server, and connect a Move Base Flex Action Client to the default Move Base Flex Action Server. mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 10 )) mb_as = actionlib . SimpleActionServer ( 'move_base' , mb_msgs . MoveBaseAction , mb_execute_cb , auto_start = False ) We then relay the goal in the callback of the Move Base Action Server, like in the first subriber callback example def mb_execute_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg . target_pose ), feedback_cb = mbf_feedback_cb ) On the client side, we simply connect to the Move Base Action Server, and send a goal, which is then relayed in the above function. client = actionlib . SimpleActionClient ( 'move_base' , mb_msgs . MoveBaseAction ) client . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to SimpleActionServer 'move_base'\" ) In this example, the robot will follow a (rough) circular path around the turtlebot3_gazebo world. A goal is created like this: goal = mb_msgs . MoveBaseGoal () goal . target_pose . header . frame_id = \"map\" goal . target_pose . header . stamp = rospy . Time . now () goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z goal . target_pose . pose . orientation . x = xx goal . target_pose . pose . orientation . y = yy goal . target_pose . pose . orientation . z = zz goal . target_pose . pose . orientation . w = ww return goal and sent to the action server: client . send_goal ( goal ) client . wait_for_result () return client . get_state () == GoalStatus . SUCCEEDED","title":"The Code Explained"},{"location":"tutorials/beginner/basic_navigation/#run-the-example","text":"Launch gazebo export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch as well as the server export TURTLEBOT3_MODEL = burger roslaunch mbf_beginner amcl_demo_relay_server.launch and client node to send the goals! rosrun mbf_beginner mb_relay_client.py","title":"Run the example"},{"location":"tutorials/beginner/basic_navigation/#the-result","text":"Open RViz with roslaunch mbf_beginner rviz.launch The full source code can be found here .","title":"The Result"},{"location":"tutorials/beginner/beyond_relay/","text":"Leaving the Relay Behind Using a relay from Move Base to Move Base Flex is the easiest way to get started with Move Base Flex, when coming from Move Base. This does, however, make it harder to use advanced features of Move Base Flex. Let's start with understanding the differences between the respective Actions: mb_msgs/MoveBaseAction vs mbf_msgs/MoveBaseAction mb_msgs/MoveBaseAction In principle, every Move Base Action is defined as geometry_msgs/PoseStamped target_pose --- No Result Feedback (default) --- geometry_msgs/PoseStamped base_position Source mbf_msgs/MoveBaseAction Move Base Flex uses the same target/result feedback/action feedback structure, but adds new functionality: More detailed result feedback (per default) More defailed feedback possibilities plugins: controller (local planner), planner (global planner), recovery_behaviors geometry_msgs/PoseStamped target_pose # Controller to use; defaults to the first one specified on \"controllers\" parameter string controller # Planner to use; defaults to the first one specified on \"planners\" parameter string planner # Recovery behaviors to try on case of failure; defaults to the \"recovery_behaviors\" parameter value string[] recovery_behaviors --- # Predefined success codes: uint8 SUCCESS = 0 # Predefined general error codes: uint8 FAILURE = 10 uint8 CANCELED = 11 uint8 COLLISION = 12 uint8 OSCILLATION = 13 uint8 START_BLOCKED = 14 uint8 GOAL_BLOCKED = 15 uint8 TF_ERROR = 16 uint8 INTERNAL_ERROR = 17 # 21..49 are reserved for future general error codes # Planning/controlling failures: uint8 PLAN_FAILURE = 50 # 51..99 are reserved as planner specific errors uint8 CTRL_FAILURE = 100 # 101..149 are reserved as controller specific errors uint32 outcome string message # Configuration upon action completion float32 dist_to_goal float32 angle_to_goal geometry_msgs/PoseStamped final_pose --- # Outcome of most recent controller cycle. Same values as in MoveBase or ExePath result. uint32 outcome string message float32 dist_to_goal float32 angle_to_goal geometry_msgs/PoseStamped current_pose geometry_msgs/TwistStamped last_cmd_vel # last command calculated by the controller` Source Interacting with Move Base Flex From a client perspective, the primary interface to work with Move Base Flex is the actionlibs SimpleActionServer. If you have never heard of actionlib, the ROS Wiki has some good tutorials for it. We did, however, already use actionlib in earlier parts of this tutorial. In principle, a SimpleActionServer expects a name and an action (ROS message type) that it will perform. A SimpleActionClient can then connect to the Server by name and Action and send respective goals , which are just the specific action with a ROS header and Goal ID. Driving a Circle with Move Base Flex In the previous example, we used a relay to Move Base with a Move Base SimpleActionServer . Using this method, the Move Base Flex is hidden, so to speak, inside the relay, and the corresponding Move Base Client is limited to the functionality of the Move Base Action Server. The following example will use the additional information the Move Base Flex Action Server provides. We can use the Move Base Flex Action server that is started with Move Base Flex to interact with the framework directly. This is the circle driving robot with Move Base Flex only. Code import actionlib import rospy import mbf_msgs.msg as mbf_msgs def create_goal ( x , y , z , xx , yy , zz , ww ): goal = mbf_msgs . MoveBaseGoal () goal . target_pose . header . frame_id = \"map\" goal . target_pose . header . stamp = rospy . Time . now () goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z goal . target_pose . pose . orientation . x = xx goal . target_pose . pose . orientation . y = yy goal . target_pose . pose . orientation . z = zz goal . target_pose . pose . orientation . w = ww return goal def move ( goal ): mbf_ac . send_goal ( goal ) mbf_ac . wait_for_result () return mbf_ac . get_result () def drive_circle (): goals = [ create_goal ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_goal ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), create_goal ( 0.957 , 1.60 , 0 , 0 , 0 , - 0.163 , 0.987 ), create_goal ( 1.8741 , 0.3830 , 0 , 0 , 0 , - 0.70 , 0.711 ), create_goal ( 1.752 , - 0.928 , 0 , 0 , 0 , - 0.856 , 0.517 ), create_goal ( 0.418 , - 2.116 , 0 , 0 , 0 , 0.998 , 0.0619 ), create_goal ( - 0.775 , - 1.80 , 0 , 0 , 0 , 0.954 , 0.300 ), create_goal ( - 1.990 , - 0.508 , 0 , 0 , 0 , - 0.112 , 0.999 ) ] for goal in goals : rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , goal . target_pose . pose . position . x , goal . target_pose . pose . position . y ) result = move ( goal ) if result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete action: %s \" , result . message ) return if __name__ == '__main__' : rospy . init_node ( \"move_base_flex_client\" ) mbf_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex action server!\" ) drive_circle () The Code Explained We start by creating the Move Base Flex Action Client that tries to connect to the server running at /move_base_flex/move_base . mbf_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex action server!\" ) To actually drive the circle, we can create goals of type mbf_msgs.MoveBaseGoal def create_goal ( x , y , z , xx , yy , zz , ww ): goal = mbf_msgs . MoveBaseGoal () goal . target_pose . header . frame_id = \"map\" goal . target_pose . header . stamp = rospy . Time . now () goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z goal . target_pose . pose . orientation . x = xx goal . target_pose . pose . orientation . y = yy goal . target_pose . pose . orientation . z = zz goal . target_pose . pose . orientation . w = ww return goal and send them to the Server def move ( goal ): mbf_ac . send_goal ( goal ) mbf_ac . wait_for_result () return mbf_ac . get_result () and can check for additional, rich result information like outcome, message and others (see first Section overview of mbf_msgs/MoveBaseAction ) if result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete action: %s \" , result . message ) return Run the example Launch gazebo export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch as well as the Move Base Flex Action Server export TURTLEBOT3_MODEL = burger roslaunch mbf_beginner amcl_demo_mbf.launch and client node to send the goals! rosrun mbf_beginner mbf_goal_client.py The Result Open RViz with roslaunch mbf_beginner rviz.launch The full source code can be found here .","title":"Beyond the Relay - Move Base Flex"},{"location":"tutorials/beginner/beyond_relay/#leaving-the-relay-behind","text":"Using a relay from Move Base to Move Base Flex is the easiest way to get started with Move Base Flex, when coming from Move Base. This does, however, make it harder to use advanced features of Move Base Flex. Let's start with understanding the differences between the respective Actions:","title":"Leaving the Relay Behind"},{"location":"tutorials/beginner/beyond_relay/#mb_msgsmovebaseaction-vs-mbf_msgsmovebaseaction","text":"mb_msgs/MoveBaseAction In principle, every Move Base Action is defined as geometry_msgs/PoseStamped target_pose --- No Result Feedback (default) --- geometry_msgs/PoseStamped base_position Source mbf_msgs/MoveBaseAction Move Base Flex uses the same target/result feedback/action feedback structure, but adds new functionality: More detailed result feedback (per default) More defailed feedback possibilities plugins: controller (local planner), planner (global planner), recovery_behaviors geometry_msgs/PoseStamped target_pose # Controller to use; defaults to the first one specified on \"controllers\" parameter string controller # Planner to use; defaults to the first one specified on \"planners\" parameter string planner # Recovery behaviors to try on case of failure; defaults to the \"recovery_behaviors\" parameter value string[] recovery_behaviors --- # Predefined success codes: uint8 SUCCESS = 0 # Predefined general error codes: uint8 FAILURE = 10 uint8 CANCELED = 11 uint8 COLLISION = 12 uint8 OSCILLATION = 13 uint8 START_BLOCKED = 14 uint8 GOAL_BLOCKED = 15 uint8 TF_ERROR = 16 uint8 INTERNAL_ERROR = 17 # 21..49 are reserved for future general error codes # Planning/controlling failures: uint8 PLAN_FAILURE = 50 # 51..99 are reserved as planner specific errors uint8 CTRL_FAILURE = 100 # 101..149 are reserved as controller specific errors uint32 outcome string message # Configuration upon action completion float32 dist_to_goal float32 angle_to_goal geometry_msgs/PoseStamped final_pose --- # Outcome of most recent controller cycle. Same values as in MoveBase or ExePath result. uint32 outcome string message float32 dist_to_goal float32 angle_to_goal geometry_msgs/PoseStamped current_pose geometry_msgs/TwistStamped last_cmd_vel # last command calculated by the controller` Source","title":"mb_msgs/MoveBaseAction vs mbf_msgs/MoveBaseAction"},{"location":"tutorials/beginner/beyond_relay/#interacting-with-move-base-flex","text":"From a client perspective, the primary interface to work with Move Base Flex is the actionlibs SimpleActionServer. If you have never heard of actionlib, the ROS Wiki has some good tutorials for it. We did, however, already use actionlib in earlier parts of this tutorial. In principle, a SimpleActionServer expects a name and an action (ROS message type) that it will perform. A SimpleActionClient can then connect to the Server by name and Action and send respective goals , which are just the specific action with a ROS header and Goal ID.","title":"Interacting with Move Base Flex"},{"location":"tutorials/beginner/beyond_relay/#driving-a-circle-with-move-base-flex","text":"In the previous example, we used a relay to Move Base with a Move Base SimpleActionServer . Using this method, the Move Base Flex is hidden, so to speak, inside the relay, and the corresponding Move Base Client is limited to the functionality of the Move Base Action Server. The following example will use the additional information the Move Base Flex Action Server provides. We can use the Move Base Flex Action server that is started with Move Base Flex to interact with the framework directly. This is the circle driving robot with Move Base Flex only.","title":"Driving a Circle with Move Base Flex"},{"location":"tutorials/beginner/beyond_relay/#code","text":"import actionlib import rospy import mbf_msgs.msg as mbf_msgs def create_goal ( x , y , z , xx , yy , zz , ww ): goal = mbf_msgs . MoveBaseGoal () goal . target_pose . header . frame_id = \"map\" goal . target_pose . header . stamp = rospy . Time . now () goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z goal . target_pose . pose . orientation . x = xx goal . target_pose . pose . orientation . y = yy goal . target_pose . pose . orientation . z = zz goal . target_pose . pose . orientation . w = ww return goal def move ( goal ): mbf_ac . send_goal ( goal ) mbf_ac . wait_for_result () return mbf_ac . get_result () def drive_circle (): goals = [ create_goal ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_goal ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), create_goal ( 0.957 , 1.60 , 0 , 0 , 0 , - 0.163 , 0.987 ), create_goal ( 1.8741 , 0.3830 , 0 , 0 , 0 , - 0.70 , 0.711 ), create_goal ( 1.752 , - 0.928 , 0 , 0 , 0 , - 0.856 , 0.517 ), create_goal ( 0.418 , - 2.116 , 0 , 0 , 0 , 0.998 , 0.0619 ), create_goal ( - 0.775 , - 1.80 , 0 , 0 , 0 , 0.954 , 0.300 ), create_goal ( - 1.990 , - 0.508 , 0 , 0 , 0 , - 0.112 , 0.999 ) ] for goal in goals : rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , goal . target_pose . pose . position . x , goal . target_pose . pose . position . y ) result = move ( goal ) if result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete action: %s \" , result . message ) return if __name__ == '__main__' : rospy . init_node ( \"move_base_flex_client\" ) mbf_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex action server!\" ) drive_circle ()","title":"Code"},{"location":"tutorials/beginner/beyond_relay/#the-code-explained","text":"We start by creating the Move Base Flex Action Client that tries to connect to the server running at /move_base_flex/move_base . mbf_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex action server!\" ) To actually drive the circle, we can create goals of type mbf_msgs.MoveBaseGoal def create_goal ( x , y , z , xx , yy , zz , ww ): goal = mbf_msgs . MoveBaseGoal () goal . target_pose . header . frame_id = \"map\" goal . target_pose . header . stamp = rospy . Time . now () goal . target_pose . pose . position . x = x goal . target_pose . pose . position . y = y goal . target_pose . pose . position . z = z goal . target_pose . pose . orientation . x = xx goal . target_pose . pose . orientation . y = yy goal . target_pose . pose . orientation . z = zz goal . target_pose . pose . orientation . w = ww return goal and send them to the Server def move ( goal ): mbf_ac . send_goal ( goal ) mbf_ac . wait_for_result () return mbf_ac . get_result () and can check for additional, rich result information like outcome, message and others (see first Section overview of mbf_msgs/MoveBaseAction ) if result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete action: %s \" , result . message ) return","title":"The Code Explained"},{"location":"tutorials/beginner/beyond_relay/#run-the-example","text":"Launch gazebo export TURTLEBOT3_MODEL = burger roslaunch turtlebot3_gazebo turtlebot3_world.launch as well as the Move Base Flex Action Server export TURTLEBOT3_MODEL = burger roslaunch mbf_beginner amcl_demo_mbf.launch and client node to send the goals! rosrun mbf_beginner mbf_goal_client.py","title":"Run the example"},{"location":"tutorials/beginner/beyond_relay/#the-result","text":"Open RViz with roslaunch mbf_beginner rviz.launch The full source code can be found here .","title":"The Result"},{"location":"tutorials/beginner/overview/","text":"Beginner Tutorial This tutorial will walk you through a Turlebot Planning Tutorial based on costmap navigation in a Gazebo simulation environment and will make you familiar with the general planning workflow of using Move Base (Flex) in ROS. Before you continue, make sure to have followed the Installation Instructions and you have a ROS workspace set up mkdir -p ~/catkin_ws/src cd ~/catkin_ws/ catkin_make Topics Basic Navigation Learn how to move a robot from point a to b with Move Base Flex and RViz. Continue here . Beyond the Relay Learn to use the Move Base Flex API directly and leave Move Base behind. Continue here . Path Planning Learn how to plan with pose paths instead of goals for greated flexibility. Continue here Parameters and Configuraton After getting to know a typical planning workflow, learn about parameters and configuration of Move Base Flex. Continue here The full source code can be found here .","title":"Overview"},{"location":"tutorials/beginner/overview/#beginner-tutorial","text":"This tutorial will walk you through a Turlebot Planning Tutorial based on costmap navigation in a Gazebo simulation environment and will make you familiar with the general planning workflow of using Move Base (Flex) in ROS. Before you continue, make sure to have followed the Installation Instructions and you have a ROS workspace set up mkdir -p ~/catkin_ws/src cd ~/catkin_ws/ catkin_make","title":"Beginner Tutorial"},{"location":"tutorials/beginner/overview/#topics","text":"Basic Navigation Learn how to move a robot from point a to b with Move Base Flex and RViz. Continue here . Beyond the Relay Learn to use the Move Base Flex API directly and leave Move Base behind. Continue here . Path Planning Learn how to plan with pose paths instead of goals for greated flexibility. Continue here Parameters and Configuraton After getting to know a typical planning workflow, learn about parameters and configuration of Move Base Flex. Continue here The full source code can be found here .","title":"Topics"},{"location":"tutorials/beginner/path_planning/","text":"Path Planning These tutorials have focused on sending goals to Move Base Flex via its Simple Action Client listening to /move_base_flex/move_base . In many instances, it is helpful to have access to the full planned path, which this tutorial will cover! Code The turtlebot will drive the same circle as in previous tutorials, but will use the /move_base_flex/exe_path Action Server to execute path goals, and the /move_base_flex/get_path Action Server to plan paths to target poses. import actionlib import rospy import mbf_msgs.msg as mbf_msgs import geometry_msgs.msg as geometry_msgs def create_pose ( x , y , z , xx , yy , zz , ww ): pose = geometry_msgs . PoseStamped () pose . header . frame_id = \"map\" pose . header . stamp = rospy . Time . now () pose . pose . position . x = x pose . pose . position . y = y pose . pose . position . z = z pose . pose . orientation . x = xx pose . pose . orientation . y = yy pose . pose . orientation . z = zz pose . pose . orientation . w = ww return pose def create_path_goal ( path , tolerance_from_action , dist_tolerance , angle_tolerance ): goal = mbf_msgs . ExePathGoal () goal . path = path goal . tolerance_from_action = tolerance_from_action goal . dist_tolerance = dist_tolerance goal . angle_tolerance = angle_tolerance return goal def exe_path ( path_goal ): mbf_ep_ac . send_goal ( path_goal ) mbf_ep_ac . wait_for_result () return mbf_ep_ac . get_result () def get_plan ( pose ): path_goal = mbf_msgs . GetPathGoal ( target_pose = pose , tolerance = 0.5 ) mbf_gp_ac . send_goal ( path_goal ) mbf_gp_ac . wait_for_result () return mbf_gp_ac . get_result () def drive_circle (): target_poses = [ create_pose ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_pose ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), create_pose ( 0.957 , 1.60 , 0 , 0 , 0 , - 0.163 , 0.987 ), create_pose ( 1.8741 , 0.3830 , 0 , 0 , 0 , - 0.70 , 0.711 ), create_pose ( 1.752 , - 0.928 , 0 , 0 , 0 , - 0.856 , 0.517 ), create_pose ( 0.418 , - 2.116 , 0 , 0 , 0 , 0.998 , 0.0619 ), create_pose ( - 0.775 , - 1.80 , 0 , 0 , 0 , 0.954 , 0.300 ), create_pose ( - 1.990 , - 0.508 , 0 , 0 , 0 , - 0.112 , 0.999 ) ] for target_pose in target_poses : rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , target_pose . pose . position . x , target_pose . pose . position . y ) get_path_result = get_plan ( target_pose ) if get_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete plan: %s \" , result . message ) return path_goal = create_path_goal ( get_path_result . path , True , 0.5 , 3.14 / 18.0 ) exe_path_result = exe_path ( path_goal ) if exe_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete exe: %s \" , result . message ) return if __name__ == '__main__' : rospy . init_node ( \"move_base_flex_client\" ) # move_base_flex exe path client mbf_ep_ac = actionlib . SimpleActionClient ( \"move_base_flex/exe_path\" , mbf_msgs . ExePathAction ) mbf_ep_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex ExePath server!\" ) # move base flex get path client mbf_gp_ac = actionlib . SimpleActionClient ( \"move_base_flex/get_path\" , mbf_msgs . GetPathAction ) mbf_gp_ac . wait_for_server ( rospy . Duration ( 10 )) drive_circle () rospy . on_shutdown ( lambda : mbf_ep_ac . cancel_all_goals ()) The Code Explained In order to execute a planned path, we need to connect to the proper Action Server: # move_base_flex exe path client mbf_ep_ac = actionlib . SimpleActionClient ( \"move_base_flex/exe_path\" , mbf_msgs . ExePathAction ) mbf_ep_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex ExePath server!\" ) For planning itself, we need to connect to the appropriate Action Server, as well: # move base flex get path client mbf_gp_ac = actionlib . SimpleActionClient ( \"move_base_flex/get_path\" , mbf_msgs . GetPathAction ) mbf_gp_ac . wait_for_server ( rospy . Duration ( 10 )) The main loop handles multiple things: planning a path def get_plan ( pose ): path_goal = mbf_msgs . GetPathGoal ( target_pose = pose , tolerance = 0.5 ) mbf_gp_ac . send_goal ( path_goal ) mbf_gp_ac . wait_for_result () return mbf_gp_ac . get_result () Creating an ExePathGoal def create_path_goal ( path , tolerance_from_action , dist_tolerance , angle_tolerance ): goal = mbf_msgs . ExePathGoal () goal . path = path goal . tolerance_from_action = tolerance_from_action goal . dist_tolerance = dist_tolerance goal . angle_tolerance = angle_tolerance return goal Sending ExePathGoal to the /move_base_flex/exe_path Action Server: def exe_path ( path_goal ): mbf_ep_ac . send_goal ( path_goal ) mbf_ep_ac . wait_for_result () return mbf_ep_ac . get_result () These steps are performed for each target pose: for target_pose in target_poses : rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , target_pose . pose . position . x , target_pose . pose . position . y ) get_path_result = get_plan ( target_pose ) if get_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete plan: %s \" , result . message ) return path_goal = create_path_goal ( get_path_result . path , True , 0.5 , 3.14 / 18.0 ) exe_path_result = exe_path ( path_goal ) if exe_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete exe: %s \" , result . message ) return The full source code can be found here .","title":"Path Planning"},{"location":"tutorials/beginner/path_planning/#path-planning","text":"These tutorials have focused on sending goals to Move Base Flex via its Simple Action Client listening to /move_base_flex/move_base . In many instances, it is helpful to have access to the full planned path, which this tutorial will cover!","title":"Path Planning"},{"location":"tutorials/beginner/path_planning/#code","text":"The turtlebot will drive the same circle as in previous tutorials, but will use the /move_base_flex/exe_path Action Server to execute path goals, and the /move_base_flex/get_path Action Server to plan paths to target poses. import actionlib import rospy import mbf_msgs.msg as mbf_msgs import geometry_msgs.msg as geometry_msgs def create_pose ( x , y , z , xx , yy , zz , ww ): pose = geometry_msgs . PoseStamped () pose . header . frame_id = \"map\" pose . header . stamp = rospy . Time . now () pose . pose . position . x = x pose . pose . position . y = y pose . pose . position . z = z pose . pose . orientation . x = xx pose . pose . orientation . y = yy pose . pose . orientation . z = zz pose . pose . orientation . w = ww return pose def create_path_goal ( path , tolerance_from_action , dist_tolerance , angle_tolerance ): goal = mbf_msgs . ExePathGoal () goal . path = path goal . tolerance_from_action = tolerance_from_action goal . dist_tolerance = dist_tolerance goal . angle_tolerance = angle_tolerance return goal def exe_path ( path_goal ): mbf_ep_ac . send_goal ( path_goal ) mbf_ep_ac . wait_for_result () return mbf_ep_ac . get_result () def get_plan ( pose ): path_goal = mbf_msgs . GetPathGoal ( target_pose = pose , tolerance = 0.5 ) mbf_gp_ac . send_goal ( path_goal ) mbf_gp_ac . wait_for_result () return mbf_gp_ac . get_result () def drive_circle (): target_poses = [ create_pose ( - 1.75 , 0.74 , 0 , 0 , 0 , 0.539 , 0.843 ), create_pose ( - 0.36 , 1.92 , 0 , 0 , 0 , - 0.020 , 0.999 ), create_pose ( 0.957 , 1.60 , 0 , 0 , 0 , - 0.163 , 0.987 ), create_pose ( 1.8741 , 0.3830 , 0 , 0 , 0 , - 0.70 , 0.711 ), create_pose ( 1.752 , - 0.928 , 0 , 0 , 0 , - 0.856 , 0.517 ), create_pose ( 0.418 , - 2.116 , 0 , 0 , 0 , 0.998 , 0.0619 ), create_pose ( - 0.775 , - 1.80 , 0 , 0 , 0 , 0.954 , 0.300 ), create_pose ( - 1.990 , - 0.508 , 0 , 0 , 0 , - 0.112 , 0.999 ) ] for target_pose in target_poses : rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , target_pose . pose . position . x , target_pose . pose . position . y ) get_path_result = get_plan ( target_pose ) if get_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete plan: %s \" , result . message ) return path_goal = create_path_goal ( get_path_result . path , True , 0.5 , 3.14 / 18.0 ) exe_path_result = exe_path ( path_goal ) if exe_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete exe: %s \" , result . message ) return if __name__ == '__main__' : rospy . init_node ( \"move_base_flex_client\" ) # move_base_flex exe path client mbf_ep_ac = actionlib . SimpleActionClient ( \"move_base_flex/exe_path\" , mbf_msgs . ExePathAction ) mbf_ep_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex ExePath server!\" ) # move base flex get path client mbf_gp_ac = actionlib . SimpleActionClient ( \"move_base_flex/get_path\" , mbf_msgs . GetPathAction ) mbf_gp_ac . wait_for_server ( rospy . Duration ( 10 )) drive_circle () rospy . on_shutdown ( lambda : mbf_ep_ac . cancel_all_goals ())","title":"Code"},{"location":"tutorials/beginner/path_planning/#the-code-explained","text":"In order to execute a planned path, we need to connect to the proper Action Server: # move_base_flex exe path client mbf_ep_ac = actionlib . SimpleActionClient ( \"move_base_flex/exe_path\" , mbf_msgs . ExePathAction ) mbf_ep_ac . wait_for_server ( rospy . Duration ( 10 )) rospy . loginfo ( \"Connected to Move Base Flex ExePath server!\" ) For planning itself, we need to connect to the appropriate Action Server, as well: # move base flex get path client mbf_gp_ac = actionlib . SimpleActionClient ( \"move_base_flex/get_path\" , mbf_msgs . GetPathAction ) mbf_gp_ac . wait_for_server ( rospy . Duration ( 10 )) The main loop handles multiple things: planning a path def get_plan ( pose ): path_goal = mbf_msgs . GetPathGoal ( target_pose = pose , tolerance = 0.5 ) mbf_gp_ac . send_goal ( path_goal ) mbf_gp_ac . wait_for_result () return mbf_gp_ac . get_result () Creating an ExePathGoal def create_path_goal ( path , tolerance_from_action , dist_tolerance , angle_tolerance ): goal = mbf_msgs . ExePathGoal () goal . path = path goal . tolerance_from_action = tolerance_from_action goal . dist_tolerance = dist_tolerance goal . angle_tolerance = angle_tolerance return goal Sending ExePathGoal to the /move_base_flex/exe_path Action Server: def exe_path ( path_goal ): mbf_ep_ac . send_goal ( path_goal ) mbf_ep_ac . wait_for_result () return mbf_ep_ac . get_result () These steps are performed for each target pose: for target_pose in target_poses : rospy . loginfo ( \"Attempting to reach ( %1.3f , %1.3f )\" , target_pose . pose . position . x , target_pose . pose . position . y ) get_path_result = get_plan ( target_pose ) if get_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete plan: %s \" , result . message ) return path_goal = create_path_goal ( get_path_result . path , True , 0.5 , 3.14 / 18.0 ) exe_path_result = exe_path ( path_goal ) if exe_path_result . outcome != mbf_msgs . MoveBaseResult . SUCCESS : rospy . loginfo ( \"Unable to complete exe: %s \" , result . message ) return The full source code can be found here .","title":"The Code Explained"},{"location":"tutorials/beginner/parameters/mbf_parameters/","text":"MBF Parameters Dynamically Reconfigurable MBF Parameters The following parameters are changable at runtime, with rqt_reconfigure , or with launch file arguments Planners The global planner handles the actual path planning. There are many options available, but the default is navfn/NavfnROS . Name Explanation Default planners global planner, e.g. navfn/NavfnROS planner_frequency The rate in Hz at which to run the planning loop 0.0 ?? planner_max_retries How many times we will recall the planner in an attempt to find a valid plan before giving up -1. ?? planner_patience How long the planner will wait in seconds in an attempt to find a valid plan before giving up 5.0 Controllers The controller handles generating control signals for the path generated by the global planner. Popular choices are DWALocalPlanner or EBandLocalPlanner. Name Explanation Default controllers list of controller, e.g. eband_local_planner/EBandPlannerROS controller_frequency The rate in Hz at which to run the control loop and send velocity commands to the base 20.0 controller_max_retries How many times we will recall the controller in an attempt to find a valid command before giving up -1 controller_patience How long the controller will wait in seconds without receiving a valid control before giving up 5.0 Oscillation Name Explanation Default oscillation_distance How far in meters the robot must move to be considered not to be oscillating 0.5 oscillation_timeout How long in seconds to allow for oscillation before executing recovery behaviors 0.0 Other Name Explanation Default recovery_enabled enable the move_base_flex recovery behaviors to attempt to clear out space true recovery_patience How much time we allow recovery behaviors to complete before canceling (or stopping if cancel fails) 15.0 restore_defaults Restore to the original configuration false shutdown_costmaps shutdown the costmaps of the node when move_base_flex is in an inactive state false shutdown_costmaps_delay How long in seconds to wait after last action before shutting down the costmaps 1.0 Example The beginner tutorials uses this configuration, for example planners: - name: navfn/NavfnROS type: navfn/NavfnROS controllers: - name: eband_local_planner/EBandPlannerROS type: eband_local_planner/EBandPlannerROS controller_frequency: 5.0 controller_patience: 3.0 planner_frequency: 1.0 planner_patience: 5.0 oscillation_timeout: 10.0 oscillation_distance: 0.2 and loads these initial parameters (among others) in the launch file <launch> <arg name= \"model\" default= \"$(env TURTLEBOT3_MODEL)\" doc= \"model type [burger, waffle, waffle_pi]\" /> <node name= \"move_base_flex\" pkg= \"mbf_costmap_nav\" type= \"mbf_costmap_nav\" required= \"true\" output= \"screen\" clear_params= \"true\" > <rosparam file= \"$(find turtlebot3_navigation)/param/costmap_common_params_$(arg model).yaml\" command= \"load\" ns= \"global_costmap\" /> <rosparam file= \"$(find turtlebot3_navigation)/param/costmap_common_params_$(arg model).yaml\" command= \"load\" ns= \"local_costmap\" /> <rosparam file= \"$(find turtlebot3_navigation)/param/local_costmap_params.yaml\" command= \"load\" /> <rosparam file= \"$(find turtlebot3_navigation)/param/global_costmap_params.yaml\" command= \"load\" /> => <rosparam file= \"$(find mbf_beginner)/param/move_base_flex.yaml\" command= \"load\" /> </node> </launch> Sources mbf_abstract_nav mbf_costmap_nav To use rqt_reconfigure , run rosrun rqt_reconfigure rqt_reconfigure Static Parameters Move Base Flex has a number of parameters, that are not dynamically changable Name Explanation Default robot_frame the frame of the robot, which will be used to determine its position \"base_link\" map_frame the global frame the robot is controlling in \"map\" force_stop_at_goal force move base flex to stop the robot once the goal is reached false force_stop_on_cancel force move base flex to stop the robot on navigation cancellation false mbf_tolerance_check force move base flex to check for the goal tolerance false dist_tolerance distance tolerance to the given goal pose 0.1 angle_tolerance angle tolerance to the given goal pose \u03c0 / 18.0 tf_timeout time before a timeout used for tf requests 1.0 Global Costmap TODO Local Costmap TODO","title":"MBF Parameters"},{"location":"tutorials/beginner/parameters/mbf_parameters/#mbf-parameters","text":"","title":"MBF Parameters"},{"location":"tutorials/beginner/parameters/mbf_parameters/#dynamically-reconfigurable-mbf-parameters","text":"The following parameters are changable at runtime, with rqt_reconfigure , or with launch file arguments","title":"Dynamically Reconfigurable MBF Parameters"},{"location":"tutorials/beginner/parameters/mbf_parameters/#planners","text":"The global planner handles the actual path planning. There are many options available, but the default is navfn/NavfnROS . Name Explanation Default planners global planner, e.g. navfn/NavfnROS planner_frequency The rate in Hz at which to run the planning loop 0.0 ?? planner_max_retries How many times we will recall the planner in an attempt to find a valid plan before giving up -1. ?? planner_patience How long the planner will wait in seconds in an attempt to find a valid plan before giving up 5.0","title":"Planners"},{"location":"tutorials/beginner/parameters/mbf_parameters/#controllers","text":"The controller handles generating control signals for the path generated by the global planner. Popular choices are DWALocalPlanner or EBandLocalPlanner. Name Explanation Default controllers list of controller, e.g. eband_local_planner/EBandPlannerROS controller_frequency The rate in Hz at which to run the control loop and send velocity commands to the base 20.0 controller_max_retries How many times we will recall the controller in an attempt to find a valid command before giving up -1 controller_patience How long the controller will wait in seconds without receiving a valid control before giving up 5.0","title":"Controllers"},{"location":"tutorials/beginner/parameters/mbf_parameters/#oscillation","text":"Name Explanation Default oscillation_distance How far in meters the robot must move to be considered not to be oscillating 0.5 oscillation_timeout How long in seconds to allow for oscillation before executing recovery behaviors 0.0","title":"Oscillation"},{"location":"tutorials/beginner/parameters/mbf_parameters/#other","text":"Name Explanation Default recovery_enabled enable the move_base_flex recovery behaviors to attempt to clear out space true recovery_patience How much time we allow recovery behaviors to complete before canceling (or stopping if cancel fails) 15.0 restore_defaults Restore to the original configuration false shutdown_costmaps shutdown the costmaps of the node when move_base_flex is in an inactive state false shutdown_costmaps_delay How long in seconds to wait after last action before shutting down the costmaps 1.0","title":"Other"},{"location":"tutorials/beginner/parameters/mbf_parameters/#example","text":"The beginner tutorials uses this configuration, for example planners: - name: navfn/NavfnROS type: navfn/NavfnROS controllers: - name: eband_local_planner/EBandPlannerROS type: eband_local_planner/EBandPlannerROS controller_frequency: 5.0 controller_patience: 3.0 planner_frequency: 1.0 planner_patience: 5.0 oscillation_timeout: 10.0 oscillation_distance: 0.2 and loads these initial parameters (among others) in the launch file <launch> <arg name= \"model\" default= \"$(env TURTLEBOT3_MODEL)\" doc= \"model type [burger, waffle, waffle_pi]\" /> <node name= \"move_base_flex\" pkg= \"mbf_costmap_nav\" type= \"mbf_costmap_nav\" required= \"true\" output= \"screen\" clear_params= \"true\" > <rosparam file= \"$(find turtlebot3_navigation)/param/costmap_common_params_$(arg model).yaml\" command= \"load\" ns= \"global_costmap\" /> <rosparam file= \"$(find turtlebot3_navigation)/param/costmap_common_params_$(arg model).yaml\" command= \"load\" ns= \"local_costmap\" /> <rosparam file= \"$(find turtlebot3_navigation)/param/local_costmap_params.yaml\" command= \"load\" /> <rosparam file= \"$(find turtlebot3_navigation)/param/global_costmap_params.yaml\" command= \"load\" /> => <rosparam file= \"$(find mbf_beginner)/param/move_base_flex.yaml\" command= \"load\" /> </node> </launch>","title":"Example"},{"location":"tutorials/beginner/parameters/mbf_parameters/#sources","text":"mbf_abstract_nav mbf_costmap_nav To use rqt_reconfigure , run rosrun rqt_reconfigure rqt_reconfigure","title":"Sources"},{"location":"tutorials/beginner/parameters/mbf_parameters/#static-parameters","text":"Move Base Flex has a number of parameters, that are not dynamically changable Name Explanation Default robot_frame the frame of the robot, which will be used to determine its position \"base_link\" map_frame the global frame the robot is controlling in \"map\" force_stop_at_goal force move base flex to stop the robot once the goal is reached false force_stop_on_cancel force move base flex to stop the robot on navigation cancellation false mbf_tolerance_check force move base flex to check for the goal tolerance false dist_tolerance distance tolerance to the given goal pose 0.1 angle_tolerance angle tolerance to the given goal pose \u03c0 / 18.0 tf_timeout time before a timeout used for tf requests 1.0","title":"Static Parameters"},{"location":"tutorials/beginner/parameters/mbf_parameters/#global-costmap","text":"TODO","title":"Global Costmap"},{"location":"tutorials/beginner/parameters/mbf_parameters/#local-costmap","text":"TODO","title":"Local Costmap"},{"location":"tutorials/beginner/parameters/overview/","text":"Parameters and Configuration After seeing the ROS Navigation Stack in action, its fitting to take a step back to understand more of what's happening under the hood. If you have never heard of the ROS Navigation Stack, we suggest reading the official documentation . If you are intested in modifying an existing Move Base Flex configuration, continue with the tutorial .","title":"Overview"},{"location":"tutorials/beginner/parameters/overview/#parameters-and-configuration","text":"After seeing the ROS Navigation Stack in action, its fitting to take a step back to understand more of what's happening under the hood. If you have never heard of the ROS Navigation Stack, we suggest reading the official documentation . If you are intested in modifying an existing Move Base Flex configuration, continue with the tutorial .","title":"Parameters and Configuration"},{"location":"tutorials/expert/overview/","text":"Expert Tutorial TODO","title":"Overview"},{"location":"tutorials/expert/overview/#expert-tutorial","text":"TODO","title":"Expert Tutorial"}]}